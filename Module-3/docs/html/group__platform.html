<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UART Console: Platform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UART Console
   </div>
   <div id="projectbrief">Modify UART Console to print stack and registers and memory</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__platform.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle"><div class="title">Platform</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback&lt; F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed_1_1detail_1_1nil.html">mbed::detail::nil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed_1_1detail_1_1enable__if.html">mbed::detail::enable_if&lt; B, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed_1_1detail_1_1enable__if_3_01false_00_01_r_01_4.html">mbed::detail::enable_if&lt; false, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed_1_1detail_1_1is__type.html">mbed::detail::is_type&lt; M, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_08_4.html">mbed::Callback&lt; R(A0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_08_4.html">mbed::Callback&lt; R(A0, A1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_08_4.html">mbed::Callback&lt; R(A0, A1, A2)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_00_01_a4_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_call_chain.html">mbed::CallChain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thunk.html">CThunk&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_function_pointer_arg1.html">mbed::FunctionPointerArg1&lt; R, A1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_function_pointer_arg1_3_01_r_00_01void_01_4.html">mbed::FunctionPointerArg1&lt; R, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed__stats__heap__t.html">mbed_stats_heap_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_platform_mutex.html">PlatformMutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_singleton_ptr.html">SingletonPtr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmbed_1_1transaction__t.html">mbed::transaction_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_transaction.html">mbed::Transaction&lt; Class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1f32135aae98d82dbbb94eec25392ff9"><td class="memItemLeft" align="right" valign="top"><a id="ga1f32135aae98d82dbbb94eec25392ff9" name="ga1f32135aae98d82dbbb94eec25392ff9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTHUNK_ADDRESS</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga1f32135aae98d82dbbb94eec25392ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4cb6d116f18cc1fe2dec7c7e97a336"><td class="memItemLeft" align="right" valign="top"><a id="ga6d4cb6d116f18cc1fe2dec7c7e97a336" name="ga6d4cb6d116f18cc1fe2dec7c7e97a336"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTHUNK_VARIABLES</b>&#160;&#160;&#160;volatile uint32_t code[2]</td></tr>
<tr class="separator:ga6d4cb6d116f18cc1fe2dec7c7e97a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb68573313abfce1681c990c68fb089"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2fb68573313abfce1681c990c68fb089">MBED_ASSERT</a>(expr)</td></tr>
<tr class="separator:ga2fb68573313abfce1681c990c68fb089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab8ec75d3f2ad841b5ede19656902c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadab8ec75d3f2ad841b5ede19656902c5">MBED_STATIC_ASSERT</a>(expr,  msg)&#160;&#160;&#160;    enum {<a class="el" href="group__platform.html#ga6944490e766215f9932c933a35219422">MBED_CONCAT</a>(MBED_ASSERTION_AT_, __LINE__) = sizeof(char[(expr) ? 1 : -1])}</td></tr>
<tr class="separator:gadab8ec75d3f2ad841b5ede19656902c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc404d96975271a839d5f130461e4c77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc404d96975271a839d5f130461e4c77">MBED_STRUCT_STATIC_ASSERT</a>(expr,  msg)&#160;&#160;&#160;int : (expr) ? 0 : -1</td></tr>
<tr class="separator:gadc404d96975271a839d5f130461e4c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf8b3130e0b5b53e186b00c49f2763e"><td class="memItemLeft" align="right" valign="top"><a id="ga0cf8b3130e0b5b53e186b00c49f2763e" name="ga0cf8b3130e0b5b53e186b00c49f2763e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_INTERFACE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga0cf8b3130e0b5b53e186b00c49f2763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbc4daf7bf19ad7759c0c30db68afba"><td class="memItemLeft" align="right" valign="top"><a id="gaddbc4daf7bf19ad7759c0c30db68afba" name="gaddbc4daf7bf19ad7759c0c30db68afba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_0</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:gaddbc4daf7bf19ad7759c0c30db68afba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaabc4901547320ba810804437df88925"><td class="memItemLeft" align="right" valign="top"><a id="gaaabc4901547320ba810804437df88925" name="gaaabc4901547320ba810804437df88925"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_1</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:gaaabc4901547320ba810804437df88925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c551e933dc64fa64b10378c052e7d14"><td class="memItemLeft" align="right" valign="top"><a id="ga7c551e933dc64fa64b10378c052e7d14" name="ga7c551e933dc64fa64b10378c052e7d14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_2</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:ga7c551e933dc64fa64b10378c052e7d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9f4065ece6e517185e81884f2c82b4"><td class="memItemLeft" align="right" valign="top"><a id="ga1e9f4065ece6e517185e81884f2c82b4" name="ga1e9f4065ece6e517185e81884f2c82b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_3</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:ga1e9f4065ece6e517185e81884f2c82b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b98720603b6584f1e650fa40d7d02f7"><td class="memItemLeft" align="right" valign="top"><a id="ga1b98720603b6584f1e650fa40d7d02f7" name="ga1b98720603b6584f1e650fa40d7d02f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_4</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:ga1b98720603b6584f1e650fa40d7d02f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648f0488f10dc10cbad1876dbef129d6"><td class="memItemLeft" align="right" valign="top"><a id="ga648f0488f10dc10cbad1876dbef129d6" name="ga648f0488f10dc10cbad1876dbef129d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDR_5</b>&#160;&#160;&#160;MBED_MAC_ADDR_INTERFACE</td></tr>
<tr class="separator:ga648f0488f10dc10cbad1876dbef129d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa020d77a19d5803837b0295bd35d0a61"><td class="memItemLeft" align="right" valign="top"><a id="gaa020d77a19d5803837b0295bd35d0a61" name="gaa020d77a19d5803837b0295bd35d0a61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MAC_ADDRESS_SUM</b>&#160;&#160;&#160;(MBED_MAC_ADDR_0 | MBED_MAC_ADDR_1 | MBED_MAC_ADDR_2 | MBED_MAC_ADDR_3 | MBED_MAC_ADDR_4 | MBED_MAC_ADDR_5)</td></tr>
<tr class="separator:gaa020d77a19d5803837b0295bd35d0a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcf3501cb79c47d804070b3df5f0d64"><td class="memItemLeft" align="right" valign="top"><a id="gabfcf3501cb79c47d804070b3df5f0d64" name="gabfcf3501cb79c47d804070b3df5f0d64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_MEM_DEFAULT_TRACER_PREFIX</b>&#160;&#160;&#160;&quot;#&quot;</td></tr>
<tr class="separator:gabfcf3501cb79c47d804070b3df5f0d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6944490e766215f9932c933a35219422"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6944490e766215f9932c933a35219422">MBED_CONCAT</a>(a,  b)&#160;&#160;&#160;MBED_CONCAT_(a, b)</td></tr>
<tr class="separator:ga6944490e766215f9932c933a35219422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9750a8339ac85dd1cdb66f8a75fb82e3"><td class="memItemLeft" align="right" valign="top"><a id="ga9750a8339ac85dd1cdb66f8a75fb82e3" name="ga9750a8339ac85dd1cdb66f8a75fb82e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_CONCAT_</b>(a,  b)&#160;&#160;&#160;a##b</td></tr>
<tr class="separator:ga9750a8339ac85dd1cdb66f8a75fb82e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888934524aa721fb113a92f81310e8aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga888934524aa721fb113a92f81310e8aa">MBED_STRINGIFY</a>(a)&#160;&#160;&#160;MBED_STRINGIFY_(a)</td></tr>
<tr class="separator:ga888934524aa721fb113a92f81310e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf227f8fcc8e06fc4b983047532ea14e3"><td class="memItemLeft" align="right" valign="top"><a id="gaf227f8fcc8e06fc4b983047532ea14e3" name="gaf227f8fcc8e06fc4b983047532ea14e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_STRINGIFY_</b>(a)&#160;&#160;&#160;#a</td></tr>
<tr class="separator:gaf227f8fcc8e06fc4b983047532ea14e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f95037893bd45bde2587185095f4e3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9f95037893bd45bde2587185095f4e3b">MBED_PACKED</a>(struct)&#160;&#160;&#160;struct __attribute__((packed))</td></tr>
<tr class="separator:ga9f95037893bd45bde2587185095f4e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d03065d5f5d1d2096f06f31218509fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2d03065d5f5d1d2096f06f31218509fb">MBED_ALIGN</a>(N)&#160;&#160;&#160;__attribute__((aligned(N)))</td></tr>
<tr class="separator:ga2d03065d5f5d1d2096f06f31218509fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0b3dc191a8e64de80be44bbc8d5193"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a></td></tr>
<tr class="separator:ga3e0b3dc191a8e64de80be44bbc8d5193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bb5d6a31c6888e54eea75c60f06400"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a>&#160;&#160;&#160;__attribute__((weak))</td></tr>
<tr class="separator:gaa7bb5d6a31c6888e54eea75c60f06400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e5edc9118df93fb8d8aa85af2baa7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga28e5edc9118df93fb8d8aa85af2baa7a">MBED_PURE</a></td></tr>
<tr class="separator:ga28e5edc9118df93fb8d8aa85af2baa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9a9e7b05304896ba993457907b3f28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a>&#160;&#160;&#160;static inline</td></tr>
<tr class="separator:ga4f9a9e7b05304896ba993457907b3f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7676a6962d493ab9e0c692e942d618a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab7676a6962d493ab9e0c692e942d618a">MBED_NORETURN</a></td></tr>
<tr class="separator:gab7676a6962d493ab9e0c692e942d618a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612b8ce3a819349edecfc605056297fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga612b8ce3a819349edecfc605056297fc">MBED_UNREACHABLE</a>&#160;&#160;&#160;while (1)</td></tr>
<tr class="separator:ga612b8ce3a819349edecfc605056297fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7865da3333447747552904fc672ea0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3a7865da3333447747552904fc672ea0">MBED_DEPRECATED</a>(M)</td></tr>
<tr class="separator:ga3a7865da3333447747552904fc672ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2822a5c443e30d9fff9c591743ac616d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2822a5c443e30d9fff9c591743ac616d">MBED_DEPRECATED_SINCE</a>(D,  M)&#160;&#160;&#160;<a class="el" href="group__platform.html#ga3a7865da3333447747552904fc672ea0">MBED_DEPRECATED</a>(M &quot; [since &quot; D &quot;]&quot;)</td></tr>
<tr class="separator:ga2822a5c443e30d9fff9c591743ac616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dee71e8eee185cce404cecdd7e51656"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0dee71e8eee185cce404cecdd7e51656">MBED_CALLER_ADDR</a>()&#160;&#160;&#160;(NULL)</td></tr>
<tr class="separator:ga0dee71e8eee185cce404cecdd7e51656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1480e9557edcc543498ca259cee6c7d"><td class="memItemLeft" align="right" valign="top"><a id="gad1480e9557edcc543498ca259cee6c7d" name="gad1480e9557edcc543498ca259cee6c7d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WEAK</b>&#160;&#160;&#160;<a class="el" href="group__platform.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a></td></tr>
<tr class="separator:gad1480e9557edcc543498ca259cee6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d525cf4d116b2fe4ecc00222b256f1"><td class="memItemLeft" align="right" valign="top"><a id="ga36d525cf4d116b2fe4ecc00222b256f1" name="ga36d525cf4d116b2fe4ecc00222b256f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PACKED</b>&#160;&#160;&#160;<a class="el" href="group__platform.html#ga9f95037893bd45bde2587185095f4e3b">MBED_PACKED</a>()</td></tr>
<tr class="separator:ga36d525cf4d116b2fe4ecc00222b256f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77366c1bd428629dc898e188bfd182a3"><td class="memItemLeft" align="right" valign="top"><a id="ga77366c1bd428629dc898e188bfd182a3" name="ga77366c1bd428629dc898e188bfd182a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EXTERN</b>&#160;&#160;&#160;extern</td></tr>
<tr class="separator:ga77366c1bd428629dc898e188bfd182a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga53e15e26f93099055cbcd1bb202c52bb"><td class="memItemLeft" align="right" valign="top"><a id="ga53e15e26f93099055cbcd1bb202c52bb" name="ga53e15e26f93099055cbcd1bb202c52bb"></a>
typedef R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::detail::enable_if&lt; B, R &gt;::type</b></td></tr>
<tr class="separator:ga53e15e26f93099055cbcd1bb202c52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memItemLeft" align="right" valign="top"><a id="ga8c554e299aa26216c4c34d9d822b05f8" name="ga8c554e299aa26216c4c34d9d822b05f8"></a>
typedef <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void(int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::event_callback_t</b></td></tr>
<tr class="separator:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0deb66451ed70cb0c99bf0255e1562d1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">mbed::pFunctionPointer_t</a></td></tr>
<tr class="separator:ga0deb66451ed70cb0c99bf0255e1562d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec43eaffc51611b760e90c53b6eabcb3"><td class="memItemLeft" align="right" valign="top"><a id="gaec43eaffc51611b760e90c53b6eabcb3" name="gaec43eaffc51611b760e90c53b6eabcb3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>CThunkEntry</b>) (void)</td></tr>
<tr class="separator:gaec43eaffc51611b760e90c53b6eabcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43431ff2814f6db189f7267274f5501"><td class="memItemLeft" align="right" valign="top"><a id="gaf43431ff2814f6db189f7267274f5501" name="gaf43431ff2814f6db189f7267274f5501"></a>
typedef <a class="el" href="classmbed_1_1_function_pointer_arg1.html">FunctionPointerArg1</a>&lt; void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointer</b></td></tr>
<tr class="separator:gaf43431ff2814f6db189f7267274f5501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b05bedaf7cb911c344087b8449642e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga41b05bedaf7cb911c344087b8449642e">mbed_mem_trace_cb_t</a>) (uint8_t op, void *res, void *caller,...)</td></tr>
<tr class="separator:ga41b05bedaf7cb911c344087b8449642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c686f9cfb2c0113bc42a8c3f7f26b6"><td class="memItemLeft" align="right" valign="top"><a id="gae3c686f9cfb2c0113bc42a8c3f7f26b6" name="gae3c686f9cfb2c0113bc42a8c3f7f26b6"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>FILEHANDLE</b></td></tr>
<tr class="separator:gae3c686f9cfb2c0113bc42a8c3f7f26b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga726ca809ffd3d67ab4b8476646f26635"><td class="memItemLeft" align="right" valign="top"><a id="ga726ca809ffd3d67ab4b8476646f26635" name="ga726ca809ffd3d67ab4b8476646f26635"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MBED_MEM_TRACE_MALLOC</b>
, <b>MBED_MEM_TRACE_REALLOC</b>
, <b>MBED_MEM_TRACE_CALLOC</b>
, <b>MBED_MEM_TRACE_FREE</b>
 }</td></tr>
<tr class="separator:ga726ca809ffd3d67ab4b8476646f26635"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2e4291df3fcb05da24067c5469edc8ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2e4291df3fcb05da24067c5469edc8ae">mbed::Callback&lt; R()&gt;::Callback</a> (R(*func)()=0)</td></tr>
<tr class="separator:ga2e4291df3fcb05da24067c5469edc8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949e0e3768e1063116f68df324c335c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga949e0e3768e1063116f68df324c335c2">mbed::Callback&lt; R()&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;func)</td></tr>
<tr class="separator:ga949e0e3768e1063116f68df324c335c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8364dab1cf66c4560bf8f22ff9aaf2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaba8364dab1cf66c4560bf8f22ff9aaf2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaba8364dab1cf66c4560bf8f22ff9aaf2">mbed::Callback&lt; R()&gt;::Callback</a> (U *obj, R(T::*method)())</td></tr>
<tr class="separator:gaba8364dab1cf66c4560bf8f22ff9aaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de7f6c2997348d27ea825998e88cc15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3de7f6c2997348d27ea825998e88cc15"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3de7f6c2997348d27ea825998e88cc15">mbed::Callback&lt; R()&gt;::Callback</a> (const U *obj, R(T::*method)() const)</td></tr>
<tr class="separator:ga3de7f6c2997348d27ea825998e88cc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c0445cde874065854de9f1b971e4e6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0c0445cde874065854de9f1b971e4e6a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0c0445cde874065854de9f1b971e4e6a">mbed::Callback&lt; R()&gt;::Callback</a> (volatile U *obj, R(T::*method)() volatile)</td></tr>
<tr class="separator:ga0c0445cde874065854de9f1b971e4e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d482b9784f45f22af35dcb6d22b999"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab4d482b9784f45f22af35dcb6d22b999"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab4d482b9784f45f22af35dcb6d22b999">mbed::Callback&lt; R()&gt;::Callback</a> (const volatile U *obj, R(T::*method)() const volatile)</td></tr>
<tr class="separator:gab4d482b9784f45f22af35dcb6d22b999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0b470505f38c2732839c4ee4c673ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gade0b470505f38c2732839c4ee4c673ea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gade0b470505f38c2732839c4ee4c673ea">mbed::Callback&lt; R()&gt;::Callback</a> (R(*func)(T *), U *arg)</td></tr>
<tr class="separator:gade0b470505f38c2732839c4ee4c673ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c857b7511e5f539b2748f8e4b92f1ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9c857b7511e5f539b2748f8e4b92f1ef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9c857b7511e5f539b2748f8e4b92f1ef">mbed::Callback&lt; R()&gt;::Callback</a> (R(*func)(const T *), const U *arg)</td></tr>
<tr class="separator:ga9c857b7511e5f539b2748f8e4b92f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce19ed4c80e12a15a8cc4235ab78fe5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4ce19ed4c80e12a15a8cc4235ab78fe5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4ce19ed4c80e12a15a8cc4235ab78fe5">mbed::Callback&lt; R()&gt;::Callback</a> (R(*func)(volatile T *), volatile U *arg)</td></tr>
<tr class="separator:ga4ce19ed4c80e12a15a8cc4235ab78fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac188b72cd4d7ba7bbf4b66f9679d4429"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac188b72cd4d7ba7bbf4b66f9679d4429"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac188b72cd4d7ba7bbf4b66f9679d4429">mbed::Callback&lt; R()&gt;::Callback</a> (R(*func)(const volatile T *), const volatile U *arg)</td></tr>
<tr class="separator:gac188b72cd4d7ba7bbf4b66f9679d4429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ef65d588f9a5547f3099f151a4873e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga52ef65d588f9a5547f3099f151a4873e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga52ef65d588f9a5547f3099f151a4873e">mbed::Callback&lt; R()&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga52ef65d588f9a5547f3099f151a4873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df074a83438de8c950839a78025c3df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4df074a83438de8c950839a78025c3df"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4df074a83438de8c950839a78025c3df">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:ga4df074a83438de8c950839a78025c3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb0a513642fbe59ab50ddb2734c77f73"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafb0a513642fbe59ab50ddb2734c77f73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafb0a513642fbe59ab50ddb2734c77f73">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:gafb0a513642fbe59ab50ddb2734c77f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac0170de25fbd7013957744b4022e55"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabac0170de25fbd7013957744b4022e55"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabac0170de25fbd7013957744b4022e55">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:gabac0170de25fbd7013957744b4022e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50987fd79c66fbf978f10836292cb2cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga50987fd79c66fbf978f10836292cb2cc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga50987fd79c66fbf978f10836292cb2cc">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:ga50987fd79c66fbf978f10836292cb2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a48578b2a07c25aac9c1c0b55f162e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga80a48578b2a07c25aac9c1c0b55f162e">mbed::Callback&lt; R()&gt;::~Callback</a> ()</td></tr>
<tr class="separator:ga80a48578b2a07c25aac9c1c0b55f162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8526e1baef1ea1a7225ce7b22aad70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">mbed::Callback&lt; R()&gt;::attach</a> (R(*func)())</td></tr>
<tr class="separator:ga4e8526e1baef1ea1a7225ce7b22aad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63447ae6eb119c2a776cf4372a1e07f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga63447ae6eb119c2a776cf4372a1e07f2">mbed::Callback&lt; R()&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;func)</td></tr>
<tr class="separator:ga63447ae6eb119c2a776cf4372a1e07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295cb116c8e83f77e1aa6c646680c630"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga295cb116c8e83f77e1aa6c646680c630"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga295cb116c8e83f77e1aa6c646680c630">mbed::Callback&lt; R()&gt;::attach</a> (U *obj, R(T::*method)())</td></tr>
<tr class="separator:ga295cb116c8e83f77e1aa6c646680c630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2b742a3bdbba4fba504a3fd6accbbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafb2b742a3bdbba4fba504a3fd6accbbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafb2b742a3bdbba4fba504a3fd6accbbc">mbed::Callback&lt; R()&gt;::attach</a> (const U *obj, R(T::*method)() const)</td></tr>
<tr class="separator:gafb2b742a3bdbba4fba504a3fd6accbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fca53c80c2593a12139cffb24ddbca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga25fca53c80c2593a12139cffb24ddbca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga25fca53c80c2593a12139cffb24ddbca">mbed::Callback&lt; R()&gt;::attach</a> (volatile U *obj, R(T::*method)() volatile)</td></tr>
<tr class="separator:ga25fca53c80c2593a12139cffb24ddbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287a2cabe3e1fd3ed55e2560801e933b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga287a2cabe3e1fd3ed55e2560801e933b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga287a2cabe3e1fd3ed55e2560801e933b">mbed::Callback&lt; R()&gt;::attach</a> (const volatile U *obj, R(T::*method)() const volatile)</td></tr>
<tr class="separator:ga287a2cabe3e1fd3ed55e2560801e933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576f7e13607933ea49c809f7c6920661"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga576f7e13607933ea49c809f7c6920661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga576f7e13607933ea49c809f7c6920661">mbed::Callback&lt; R()&gt;::attach</a> (R(*func)(T *), U *arg)</td></tr>
<tr class="separator:ga576f7e13607933ea49c809f7c6920661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7bb2ff0ffda28d39264ca2e513a99b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3a7bb2ff0ffda28d39264ca2e513a99b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3a7bb2ff0ffda28d39264ca2e513a99b">mbed::Callback&lt; R()&gt;::attach</a> (R(*func)(const T *), const U *arg)</td></tr>
<tr class="separator:ga3a7bb2ff0ffda28d39264ca2e513a99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d11d735c6e3c64611af10b582e11a0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac8d11d735c6e3c64611af10b582e11a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac8d11d735c6e3c64611af10b582e11a0">mbed::Callback&lt; R()&gt;::attach</a> (R(*func)(volatile T *), volatile U *arg)</td></tr>
<tr class="separator:gac8d11d735c6e3c64611af10b582e11a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282a8fd44b4b8bf13c6877fc7f25819e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga282a8fd44b4b8bf13c6877fc7f25819e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga282a8fd44b4b8bf13c6877fc7f25819e">mbed::Callback&lt; R()&gt;::attach</a> (R(*func)(const volatile T *), const volatile U *arg)</td></tr>
<tr class="separator:ga282a8fd44b4b8bf13c6877fc7f25819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d49c398ad2e8e3a2d2dad77d2f20e0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga39d49c398ad2e8e3a2d2dad77d2f20e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga39d49c398ad2e8e3a2d2dad77d2f20e0">mbed::Callback&lt; R()&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga39d49c398ad2e8e3a2d2dad77d2f20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071fc43ebc9b0de5bad35a174b9fd026"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga071fc43ebc9b0de5bad35a174b9fd026"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga071fc43ebc9b0de5bad35a174b9fd026">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(U *obj</td></tr>
<tr class="separator:ga071fc43ebc9b0de5bad35a174b9fd026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ad7cff4866522574aba696c07220fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga25ad7cff4866522574aba696c07220fd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga25ad7cff4866522574aba696c07220fd">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(const U *obj</td></tr>
<tr class="separator:ga25ad7cff4866522574aba696c07220fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57299076676f942345a81f596dabfc6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab57299076676f942345a81f596dabfc6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab57299076676f942345a81f596dabfc6">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(volatile U *obj</td></tr>
<tr class="separator:gab57299076676f942345a81f596dabfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e190a3f4a04f84213d006bed8c1abc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga88e190a3f4a04f84213d006bed8c1abc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga88e190a3f4a04f84213d006bed8c1abc">mbed::Callback&lt; R()&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:ga88e190a3f4a04f84213d006bed8c1abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6a602e09673b7cf64c1027d52e0f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabc6a602e09673b7cf64c1027d52e0f74">mbed::Callback&lt; R()&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:gabc6a602e09673b7cf64c1027d52e0f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d222c1e13efe443a03379508bcc194"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga71d222c1e13efe443a03379508bcc194">mbed::Callback&lt; R()&gt;::call</a> () const</td></tr>
<tr class="separator:ga71d222c1e13efe443a03379508bcc194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2be2d70c53b801ec9c06651121cba8f"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gae2be2d70c53b801ec9c06651121cba8f">mbed::Callback&lt; R()&gt;::operator()</a> () const</td></tr>
<tr class="separator:gae2be2d70c53b801ec9c06651121cba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c8e05ae304cf02c492e46969795fe81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4c8e05ae304cf02c492e46969795fe81">mbed::Callback&lt; R()&gt;::operator bool</a> () const</td></tr>
<tr class="separator:ga4c8e05ae304cf02c492e46969795fe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0017bfc561308796ccc9d2ac247c2a"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9e0017bfc561308796ccc9d2ac247c2a">mbed::Callback&lt; R()&gt;::thunk</a> (void *func)</td></tr>
<tr class="separator:ga9e0017bfc561308796ccc9d2ac247c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d9dbc56d815dbeb57c5070f2a63f7e"><td class="memItemLeft" align="right" valign="top"><a id="gaa8d9dbc56d815dbeb57c5070f2a63f7e" name="gaa8d9dbc56d815dbeb57c5070f2a63f7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:gaa8d9dbc56d815dbeb57c5070f2a63f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5812fb319056c15a7ed7752dfda07032"><td class="memItemLeft" align="right" valign="top"><a id="ga5812fb319056c15a7ed7752dfda07032" name="ga5812fb319056c15a7ed7752dfda07032"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::method_context&lt; O, M &gt;::operator()</b> () const</td></tr>
<tr class="separator:ga5812fb319056c15a7ed7752dfda07032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a17b5152245f1ee728dd90e78e5d52"><td class="memItemLeft" align="right" valign="top"><a id="ga89a17b5152245f1ee728dd90e78e5d52" name="ga89a17b5152245f1ee728dd90e78e5d52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:ga89a17b5152245f1ee728dd90e78e5d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefffbd1e48e708f8cae5cfeb5e2f300"><td class="memItemLeft" align="right" valign="top"><a id="gafefffbd1e48e708f8cae5cfeb5e2f300" name="gafefffbd1e48e708f8cae5cfeb5e2f300"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::function_context&lt; F, A &gt;::operator()</b> () const</td></tr>
<tr class="separator:gafefffbd1e48e708f8cae5cfeb5e2f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26685399a6106a159125524b67312267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga26685399a6106a159125524b67312267">mbed::Callback&lt; R(A0)&gt;::Callback</a> (R(*func)(A0)=0)</td></tr>
<tr class="separator:ga26685399a6106a159125524b67312267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb14403a450405d7561164132943cb10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadb14403a450405d7561164132943cb10">mbed::Callback&lt; R(A0)&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;func)</td></tr>
<tr class="separator:gadb14403a450405d7561164132943cb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac487301efd13f7927ca1d1d5685187cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac487301efd13f7927ca1d1d5685187cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac487301efd13f7927ca1d1d5685187cd">mbed::Callback&lt; R(A0)&gt;::Callback</a> (U *obj, R(T::*method)(A0))</td></tr>
<tr class="separator:gac487301efd13f7927ca1d1d5685187cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed553cc1e6d6b5547190d3d47e99a0b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2ed553cc1e6d6b5547190d3d47e99a0b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2ed553cc1e6d6b5547190d3d47e99a0b">mbed::Callback&lt; R(A0)&gt;::Callback</a> (const U *obj, R(T::*method)(A0) const)</td></tr>
<tr class="separator:ga2ed553cc1e6d6b5547190d3d47e99a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8592aff9c017394291d36a04434a745d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8592aff9c017394291d36a04434a745d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8592aff9c017394291d36a04434a745d">mbed::Callback&lt; R(A0)&gt;::Callback</a> (volatile U *obj, R(T::*method)(A0) volatile)</td></tr>
<tr class="separator:ga8592aff9c017394291d36a04434a745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454e1a495babdea8b2d704c27151c949"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga454e1a495babdea8b2d704c27151c949"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga454e1a495babdea8b2d704c27151c949">mbed::Callback&lt; R(A0)&gt;::Callback</a> (const volatile U *obj, R(T::*method)(A0) const volatile)</td></tr>
<tr class="separator:ga454e1a495babdea8b2d704c27151c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b33c1983392cba4afc6edc972fde9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab9b33c1983392cba4afc6edc972fde9c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab9b33c1983392cba4afc6edc972fde9c">mbed::Callback&lt; R(A0)&gt;::Callback</a> (R(*func)(T *, A0), U *arg)</td></tr>
<tr class="separator:gab9b33c1983392cba4afc6edc972fde9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf975f1fc65dd39cb57ba2cc38946e0b0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf975f1fc65dd39cb57ba2cc38946e0b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf975f1fc65dd39cb57ba2cc38946e0b0">mbed::Callback&lt; R(A0)&gt;::Callback</a> (R(*func)(const T *, A0), const U *arg)</td></tr>
<tr class="separator:gaf975f1fc65dd39cb57ba2cc38946e0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c108754a2264a07abc7590b26d81979"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1c108754a2264a07abc7590b26d81979"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1c108754a2264a07abc7590b26d81979">mbed::Callback&lt; R(A0)&gt;::Callback</a> (R(*func)(volatile T *, A0), volatile U *arg)</td></tr>
<tr class="separator:ga1c108754a2264a07abc7590b26d81979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20acb1c81a442714971e29abca9f45f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga20acb1c81a442714971e29abca9f45f3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga20acb1c81a442714971e29abca9f45f3">mbed::Callback&lt; R(A0)&gt;::Callback</a> (R(*func)(const volatile T *, A0), const volatile U *arg)</td></tr>
<tr class="separator:ga20acb1c81a442714971e29abca9f45f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c66e66f4e9f0710c797f2733b22ef4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga66c66e66f4e9f0710c797f2733b22ef4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga66c66e66f4e9f0710c797f2733b22ef4">mbed::Callback&lt; R(A0)&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga66c66e66f4e9f0710c797f2733b22ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ac891a5d744bbd03bd590cb7b2a8fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga28ac891a5d744bbd03bd590cb7b2a8fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga28ac891a5d744bbd03bd590cb7b2a8fc">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:ga28ac891a5d744bbd03bd590cb7b2a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb411b675573ea86c84da568415b475"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7cb411b675573ea86c84da568415b475"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7cb411b675573ea86c84da568415b475">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:ga7cb411b675573ea86c84da568415b475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d12ff1e5d6642999ccbe9cd1f9e9fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga78d12ff1e5d6642999ccbe9cd1f9e9fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga78d12ff1e5d6642999ccbe9cd1f9e9fc">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:ga78d12ff1e5d6642999ccbe9cd1f9e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb57be8b1d0b6e65c65f1e194c691b82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafb57be8b1d0b6e65c65f1e194c691b82"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafb57be8b1d0b6e65c65f1e194c691b82">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:gafb57be8b1d0b6e65c65f1e194c691b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b4cbb0b3afe0f503e41c4e4da0b932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga28b4cbb0b3afe0f503e41c4e4da0b932">mbed::Callback&lt; R(A0)&gt;::~Callback</a> ()</td></tr>
<tr class="separator:ga28b4cbb0b3afe0f503e41c4e4da0b932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5c0e18f6f21537ab1b5e39c5c66ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">mbed::Callback&lt; R(A0)&gt;::attach</a> (R(*func)(A0))</td></tr>
<tr class="separator:gabb5c0e18f6f21537ab1b5e39c5c66ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5463b7573a9e3105cfb8abef698aeab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5463b7573a9e3105cfb8abef698aeab7">mbed::Callback&lt; R(A0)&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;func)</td></tr>
<tr class="separator:ga5463b7573a9e3105cfb8abef698aeab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8696d083a12693b4cdc365db92edca3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa8696d083a12693b4cdc365db92edca3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa8696d083a12693b4cdc365db92edca3">mbed::Callback&lt; R(A0)&gt;::attach</a> (U *obj, R(T::*method)(A0))</td></tr>
<tr class="separator:gaa8696d083a12693b4cdc365db92edca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709b7b6e91b664960f9ae62c8c7e11bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga709b7b6e91b664960f9ae62c8c7e11bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga709b7b6e91b664960f9ae62c8c7e11bd">mbed::Callback&lt; R(A0)&gt;::attach</a> (const U *obj, R(T::*method)(A0) const)</td></tr>
<tr class="separator:ga709b7b6e91b664960f9ae62c8c7e11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc28dcb73a90cafa92735dd1e8cfbb4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaefc28dcb73a90cafa92735dd1e8cfbb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaefc28dcb73a90cafa92735dd1e8cfbb4">mbed::Callback&lt; R(A0)&gt;::attach</a> (volatile U *obj, R(T::*method)(A0) volatile)</td></tr>
<tr class="separator:gaefc28dcb73a90cafa92735dd1e8cfbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e01eb4369945b540693db494ec9d687"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7e01eb4369945b540693db494ec9d687"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7e01eb4369945b540693db494ec9d687">mbed::Callback&lt; R(A0)&gt;::attach</a> (const volatile U *obj, R(T::*method)(A0) const volatile)</td></tr>
<tr class="separator:ga7e01eb4369945b540693db494ec9d687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203908b4e78f4d5a816a9ec9ab5ad32d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga203908b4e78f4d5a816a9ec9ab5ad32d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga203908b4e78f4d5a816a9ec9ab5ad32d">mbed::Callback&lt; R(A0)&gt;::attach</a> (R(*func)(T *, A0), U *arg)</td></tr>
<tr class="separator:ga203908b4e78f4d5a816a9ec9ab5ad32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ccacf0705e725985397bbb30e36e5b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga46ccacf0705e725985397bbb30e36e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga46ccacf0705e725985397bbb30e36e5b">mbed::Callback&lt; R(A0)&gt;::attach</a> (R(*func)(const T *, A0), const U *arg)</td></tr>
<tr class="separator:ga46ccacf0705e725985397bbb30e36e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a2cc2dbbd59746c7952ee616c2ad76"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf0a2cc2dbbd59746c7952ee616c2ad76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf0a2cc2dbbd59746c7952ee616c2ad76">mbed::Callback&lt; R(A0)&gt;::attach</a> (R(*func)(volatile T *, A0), volatile U *arg)</td></tr>
<tr class="separator:gaf0a2cc2dbbd59746c7952ee616c2ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a862ee6a2e6d750487268229c3a43a2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2a862ee6a2e6d750487268229c3a43a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2a862ee6a2e6d750487268229c3a43a2">mbed::Callback&lt; R(A0)&gt;::attach</a> (R(*func)(const volatile T *, A0), const volatile U *arg)</td></tr>
<tr class="separator:ga2a862ee6a2e6d750487268229c3a43a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db277328da843d4499e22544ab33804"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga9db277328da843d4499e22544ab33804"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9db277328da843d4499e22544ab33804">mbed::Callback&lt; R(A0)&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga9db277328da843d4499e22544ab33804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ea550c7ac335ddaf5d6f6fdce23439"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae4ea550c7ac335ddaf5d6f6fdce23439"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae4ea550c7ac335ddaf5d6f6fdce23439">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(U *obj</td></tr>
<tr class="separator:gae4ea550c7ac335ddaf5d6f6fdce23439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34090f1d90ef7ba694950264d688a67b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga34090f1d90ef7ba694950264d688a67b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga34090f1d90ef7ba694950264d688a67b">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(const U *obj</td></tr>
<tr class="separator:ga34090f1d90ef7ba694950264d688a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d24fec244d0f05e3f9c0bce94e1de4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga81d24fec244d0f05e3f9c0bce94e1de4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga81d24fec244d0f05e3f9c0bce94e1de4">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(volatile U *obj</td></tr>
<tr class="separator:ga81d24fec244d0f05e3f9c0bce94e1de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f4c9445933344b6031e5f803faf038"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga31f4c9445933344b6031e5f803faf038"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga31f4c9445933344b6031e5f803faf038">mbed::Callback&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:ga31f4c9445933344b6031e5f803faf038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072b188609cfa2ac3b7a34d31115df68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga072b188609cfa2ac3b7a34d31115df68">mbed::Callback&lt; R(A0)&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:ga072b188609cfa2ac3b7a34d31115df68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b069cffc0d8849693e970c26ecc9339"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8b069cffc0d8849693e970c26ecc9339">mbed::Callback&lt; R(A0)&gt;::call</a> (A0 a0) const</td></tr>
<tr class="separator:ga8b069cffc0d8849693e970c26ecc9339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88ec437f9316311cae3a24f24082089"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa88ec437f9316311cae3a24f24082089">mbed::Callback&lt; R(A0)&gt;::operator()</a> (A0 a0) const</td></tr>
<tr class="separator:gaa88ec437f9316311cae3a24f24082089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15fff28d8f02a51e56d972ad444aa3cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga15fff28d8f02a51e56d972ad444aa3cb">mbed::Callback&lt; R(A0)&gt;::operator bool</a> () const</td></tr>
<tr class="separator:ga15fff28d8f02a51e56d972ad444aa3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd2c178774d085bd656d4fee9fece8a"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8dd2c178774d085bd656d4fee9fece8a">mbed::Callback&lt; R(A0)&gt;::thunk</a> (void *func, A0 a0)</td></tr>
<tr class="separator:ga8dd2c178774d085bd656d4fee9fece8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedbcd2656d5b8aa6456761b992f27175"><td class="memItemLeft" align="right" valign="top"><a id="gaedbcd2656d5b8aa6456761b992f27175" name="gaedbcd2656d5b8aa6456761b992f27175"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:gaedbcd2656d5b8aa6456761b992f27175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga985d4597de66cd4903e91a671a015da8"><td class="memItemLeft" align="right" valign="top"><a id="ga985d4597de66cd4903e91a671a015da8" name="ga985d4597de66cd4903e91a671a015da8"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::method_context&lt; O, M &gt;::operator()</b> (A0 a0) const</td></tr>
<tr class="separator:ga985d4597de66cd4903e91a671a015da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a09b64b6c5a24b778a938586b5b0ca1"><td class="memItemLeft" align="right" valign="top"><a id="ga2a09b64b6c5a24b778a938586b5b0ca1" name="ga2a09b64b6c5a24b778a938586b5b0ca1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:ga2a09b64b6c5a24b778a938586b5b0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6998d4b4fd70090397741eafa59c9d02"><td class="memItemLeft" align="right" valign="top"><a id="ga6998d4b4fd70090397741eafa59c9d02" name="ga6998d4b4fd70090397741eafa59c9d02"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::function_context&lt; F, A &gt;::operator()</b> (A0 a0) const</td></tr>
<tr class="separator:ga6998d4b4fd70090397741eafa59c9d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdac7e3c27de5240ebeca217310c7a17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gafdac7e3c27de5240ebeca217310c7a17">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (R(*func)(A0, A1)=0)</td></tr>
<tr class="separator:gafdac7e3c27de5240ebeca217310c7a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619662f87e37e48596ceb69198dd1080"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga619662f87e37e48596ceb69198dd1080">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;func)</td></tr>
<tr class="separator:ga619662f87e37e48596ceb69198dd1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedad5979a6ecc5a841e999f56f54210f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaedad5979a6ecc5a841e999f56f54210f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaedad5979a6ecc5a841e999f56f54210f">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (U *obj, R(T::*method)(A0, A1))</td></tr>
<tr class="separator:gaedad5979a6ecc5a841e999f56f54210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada5aad0d58a5d868c655ce685224e0f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaada5aad0d58a5d868c655ce685224e0f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaada5aad0d58a5d868c655ce685224e0f">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (const U *obj, R(T::*method)(A0, A1) const)</td></tr>
<tr class="separator:gaada5aad0d58a5d868c655ce685224e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f8e26973c1553834fedb64f4bfb9be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga92f8e26973c1553834fedb64f4bfb9be"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga92f8e26973c1553834fedb64f4bfb9be">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (volatile U *obj, R(T::*method)(A0, A1) volatile)</td></tr>
<tr class="separator:ga92f8e26973c1553834fedb64f4bfb9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868fd79b893363e8ea5d9ab957edad2c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga868fd79b893363e8ea5d9ab957edad2c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga868fd79b893363e8ea5d9ab957edad2c">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (const volatile U *obj, R(T::*method)(A0, A1) const volatile)</td></tr>
<tr class="separator:ga868fd79b893363e8ea5d9ab957edad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4753d73ddc29c3bb9c1763a44fccd7b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4753d73ddc29c3bb9c1763a44fccd7b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4753d73ddc29c3bb9c1763a44fccd7b4">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (R(*func)(T *, A0, A1), U *arg)</td></tr>
<tr class="separator:ga4753d73ddc29c3bb9c1763a44fccd7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8c5534e0bbd8b9fdb4838db8193496"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7d8c5534e0bbd8b9fdb4838db8193496"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7d8c5534e0bbd8b9fdb4838db8193496">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (R(*func)(const T *, A0, A1), const U *arg)</td></tr>
<tr class="separator:ga7d8c5534e0bbd8b9fdb4838db8193496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf8cd388813ca592e14f7bae771aebd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1cf8cd388813ca592e14f7bae771aebd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1cf8cd388813ca592e14f7bae771aebd">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (R(*func)(volatile T *, A0, A1), volatile U *arg)</td></tr>
<tr class="separator:ga1cf8cd388813ca592e14f7bae771aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e2a2fa43a4b0c5179f09a6a31742c2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae3e2a2fa43a4b0c5179f09a6a31742c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae3e2a2fa43a4b0c5179f09a6a31742c2">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (R(*func)(const volatile T *, A0, A1), const volatile U *arg)</td></tr>
<tr class="separator:gae3e2a2fa43a4b0c5179f09a6a31742c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a5f9b9f23a112b837d983fd9e15d71"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga57a5f9b9f23a112b837d983fd9e15d71"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga57a5f9b9f23a112b837d983fd9e15d71">mbed::Callback&lt; R(A0, A1)&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga57a5f9b9f23a112b837d983fd9e15d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b12313c1b808898616163599b5f05da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2b12313c1b808898616163599b5f05da"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2b12313c1b808898616163599b5f05da">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:ga2b12313c1b808898616163599b5f05da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3d51f3cd35eaa5c2cb3765692bbdbe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0e3d51f3cd35eaa5c2cb3765692bbdbe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0e3d51f3cd35eaa5c2cb3765692bbdbe">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:ga0e3d51f3cd35eaa5c2cb3765692bbdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06111eb213ae177ab2c945e23f7323a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae06111eb213ae177ab2c945e23f7323a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae06111eb213ae177ab2c945e23f7323a">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:gae06111eb213ae177ab2c945e23f7323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacfb0f40d4af6920dd164e693327876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabacfb0f40d4af6920dd164e693327876"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabacfb0f40d4af6920dd164e693327876">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:gabacfb0f40d4af6920dd164e693327876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a65106683398bab982fac7d38a6355"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga82a65106683398bab982fac7d38a6355">mbed::Callback&lt; R(A0, A1)&gt;::~Callback</a> ()</td></tr>
<tr class="separator:ga82a65106683398bab982fac7d38a6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e92272a770036c4e598a19418ae1ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (R(*func)(A0, A1))</td></tr>
<tr class="separator:ga9e92272a770036c4e598a19418ae1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db638e222c05bd69b531d81023fed43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4db638e222c05bd69b531d81023fed43">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;func)</td></tr>
<tr class="separator:ga4db638e222c05bd69b531d81023fed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de36136736d7bd78fadfd7c8e0a4aab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6de36136736d7bd78fadfd7c8e0a4aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6de36136736d7bd78fadfd7c8e0a4aab">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (U *obj, R(T::*method)(A0, A1))</td></tr>
<tr class="separator:ga6de36136736d7bd78fadfd7c8e0a4aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c063a4b158272095eb5743aa098c602"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7c063a4b158272095eb5743aa098c602"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7c063a4b158272095eb5743aa098c602">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (const U *obj, R(T::*method)(A0, A1) const)</td></tr>
<tr class="separator:ga7c063a4b158272095eb5743aa098c602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070d4dc97296e88943cb8644ac13c108"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga070d4dc97296e88943cb8644ac13c108"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga070d4dc97296e88943cb8644ac13c108">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (volatile U *obj, R(T::*method)(A0, A1) volatile)</td></tr>
<tr class="separator:ga070d4dc97296e88943cb8644ac13c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1bedad813fa000601c77cf9dd457405"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa1bedad813fa000601c77cf9dd457405"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa1bedad813fa000601c77cf9dd457405">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (const volatile U *obj, R(T::*method)(A0, A1) const volatile)</td></tr>
<tr class="separator:gaa1bedad813fa000601c77cf9dd457405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e18c89e3fa791811090178e8752651"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gad0e18c89e3fa791811090178e8752651"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad0e18c89e3fa791811090178e8752651">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (R(*func)(T *, A0, A1), U *arg)</td></tr>
<tr class="separator:gad0e18c89e3fa791811090178e8752651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8179fc8f4e3e4866c7d8090543e1ca64"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8179fc8f4e3e4866c7d8090543e1ca64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8179fc8f4e3e4866c7d8090543e1ca64">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (R(*func)(const T *, A0, A1), const U *arg)</td></tr>
<tr class="separator:ga8179fc8f4e3e4866c7d8090543e1ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08640646b88ead8b4bb1f59bf112197e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga08640646b88ead8b4bb1f59bf112197e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga08640646b88ead8b4bb1f59bf112197e">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (R(*func)(volatile T *, A0, A1), volatile U *arg)</td></tr>
<tr class="separator:ga08640646b88ead8b4bb1f59bf112197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac585e067da7a90bafa7e2c24cfa6be8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac585e067da7a90bafa7e2c24cfa6be8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac585e067da7a90bafa7e2c24cfa6be8d">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (R(*func)(const volatile T *, A0, A1), const volatile U *arg)</td></tr>
<tr class="separator:gac585e067da7a90bafa7e2c24cfa6be8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga721437bebbd674f31810becdec566725"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga721437bebbd674f31810becdec566725"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga721437bebbd674f31810becdec566725">mbed::Callback&lt; R(A0, A1)&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga721437bebbd674f31810becdec566725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45a973d609ff9d9586f17bae0d9b040"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa45a973d609ff9d9586f17bae0d9b040"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa45a973d609ff9d9586f17bae0d9b040">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(U *obj</td></tr>
<tr class="separator:gaa45a973d609ff9d9586f17bae0d9b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ca1084295f482d158d174e26f52bc0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga71ca1084295f482d158d174e26f52bc0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga71ca1084295f482d158d174e26f52bc0">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(const U *obj</td></tr>
<tr class="separator:ga71ca1084295f482d158d174e26f52bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b2594c67a4f1025aec4662f2fc410"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gadf2b2594c67a4f1025aec4662f2fc410"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gadf2b2594c67a4f1025aec4662f2fc410">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(volatile U *obj</td></tr>
<tr class="separator:gadf2b2594c67a4f1025aec4662f2fc410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69929079b4f2a1eb42678c75dc1633dd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga69929079b4f2a1eb42678c75dc1633dd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga69929079b4f2a1eb42678c75dc1633dd">mbed::Callback&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:ga69929079b4f2a1eb42678c75dc1633dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c43a737a4b09f6a8e2a64dfdab875fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2c43a737a4b09f6a8e2a64dfdab875fb">mbed::Callback&lt; R(A0, A1)&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:ga2c43a737a4b09f6a8e2a64dfdab875fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcaeec6b608e568f05766b4a5a09998"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3fcaeec6b608e568f05766b4a5a09998">mbed::Callback&lt; R(A0, A1)&gt;::call</a> (A0 a0, A1 a1) const</td></tr>
<tr class="separator:ga3fcaeec6b608e568f05766b4a5a09998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12a59ae8df387894a3b619667201c95"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gae12a59ae8df387894a3b619667201c95">mbed::Callback&lt; R(A0, A1)&gt;::operator()</a> (A0 a0, A1 a1) const</td></tr>
<tr class="separator:gae12a59ae8df387894a3b619667201c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad541a6aee855641543ace2b301a50fcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad541a6aee855641543ace2b301a50fcf">mbed::Callback&lt; R(A0, A1)&gt;::operator bool</a> () const</td></tr>
<tr class="separator:gad541a6aee855641543ace2b301a50fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc009fa17127f9bd7c45c1a8eb95816"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7dc009fa17127f9bd7c45c1a8eb95816">mbed::Callback&lt; R(A0, A1)&gt;::thunk</a> (void *func, A0 a0, A1 a1)</td></tr>
<tr class="separator:ga7dc009fa17127f9bd7c45c1a8eb95816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845a411b031798ca270f8eb3cf9b3a68"><td class="memItemLeft" align="right" valign="top"><a id="ga845a411b031798ca270f8eb3cf9b3a68" name="ga845a411b031798ca270f8eb3cf9b3a68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:ga845a411b031798ca270f8eb3cf9b3a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02beec31bac97fb32f5d1899f7ac0c79"><td class="memItemLeft" align="right" valign="top"><a id="ga02beec31bac97fb32f5d1899f7ac0c79" name="ga02beec31bac97fb32f5d1899f7ac0c79"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::method_context&lt; O, M &gt;::operator()</b> (A0 a0, A1 a1) const</td></tr>
<tr class="separator:ga02beec31bac97fb32f5d1899f7ac0c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef759118c758b4c9968b76d899568af3"><td class="memItemLeft" align="right" valign="top"><a id="gaef759118c758b4c9968b76d899568af3" name="gaef759118c758b4c9968b76d899568af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:gaef759118c758b4c9968b76d899568af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4059d62fc24f1783c7c6806cf12f02e0"><td class="memItemLeft" align="right" valign="top"><a id="ga4059d62fc24f1783c7c6806cf12f02e0" name="ga4059d62fc24f1783c7c6806cf12f02e0"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::function_context&lt; F, A &gt;::operator()</b> (A0 a0, A1 a1) const</td></tr>
<tr class="separator:ga4059d62fc24f1783c7c6806cf12f02e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f28dd98e3ddd1254b999d9c854e572"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga12f28dd98e3ddd1254b999d9c854e572">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (R(*func)(A0, A1, A2)=0)</td></tr>
<tr class="separator:ga12f28dd98e3ddd1254b999d9c854e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4336f189ca9f689a6ab1c1e271849e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gacb4336f189ca9f689a6ab1c1e271849e">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;func)</td></tr>
<tr class="separator:gacb4336f189ca9f689a6ab1c1e271849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2edb51597b8140e71f4862a815a62ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa2edb51597b8140e71f4862a815a62ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa2edb51597b8140e71f4862a815a62ab">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (U *obj, R(T::*method)(A0, A1, A2))</td></tr>
<tr class="separator:gaa2edb51597b8140e71f4862a815a62ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5769654b8cb7a29160737f36fdb8878b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga5769654b8cb7a29160737f36fdb8878b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5769654b8cb7a29160737f36fdb8878b">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (const U *obj, R(T::*method)(A0, A1, A2) const)</td></tr>
<tr class="separator:ga5769654b8cb7a29160737f36fdb8878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4bfc5ab6980bd89851571e8ad861ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaab4bfc5ab6980bd89851571e8ad861ec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaab4bfc5ab6980bd89851571e8ad861ec">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2) volatile)</td></tr>
<tr class="separator:gaab4bfc5ab6980bd89851571e8ad861ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa277c6341de692511fd2d9899d1cd83c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa277c6341de692511fd2d9899d1cd83c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa277c6341de692511fd2d9899d1cd83c">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2) const volatile)</td></tr>
<tr class="separator:gaa277c6341de692511fd2d9899d1cd83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0866d4f19d0ed1b7a36f683c215579f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0866d4f19d0ed1b7a36f683c215579f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0866d4f19d0ed1b7a36f683c215579f9">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (R(*func)(T *, A0, A1, A2), U *arg)</td></tr>
<tr class="separator:ga0866d4f19d0ed1b7a36f683c215579f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9334dd0d02a68ab1a5f4c0efb5a6cae0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9334dd0d02a68ab1a5f4c0efb5a6cae0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9334dd0d02a68ab1a5f4c0efb5a6cae0">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (R(*func)(const T *, A0, A1, A2), const U *arg)</td></tr>
<tr class="separator:ga9334dd0d02a68ab1a5f4c0efb5a6cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c46df32895c79e9c05b862a4b08003"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae5c46df32895c79e9c05b862a4b08003"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae5c46df32895c79e9c05b862a4b08003">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (R(*func)(volatile T *, A0, A1, A2), volatile U *arg)</td></tr>
<tr class="separator:gae5c46df32895c79e9c05b862a4b08003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8226e4e0176acb5685e1c1d91098e8e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8226e4e0176acb5685e1c1d91098e8e3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8226e4e0176acb5685e1c1d91098e8e3">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (R(*func)(const volatile T *, A0, A1, A2), const volatile U *arg)</td></tr>
<tr class="separator:ga8226e4e0176acb5685e1c1d91098e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6039ea71f2a1c4058723e0c3e273cc9"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:gac6039ea71f2a1c4058723e0c3e273cc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac6039ea71f2a1c4058723e0c3e273cc9">mbed::Callback&lt; R(A0, A1, A2)&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:gac6039ea71f2a1c4058723e0c3e273cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b27ed432ab0bf0b713d9292cc6ce9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf8b27ed432ab0bf0b713d9292cc6ce9c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf8b27ed432ab0bf0b713d9292cc6ce9c">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:gaf8b27ed432ab0bf0b713d9292cc6ce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ffdb972f88f0263a5779715a51aa129"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2ffdb972f88f0263a5779715a51aa129"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2ffdb972f88f0263a5779715a51aa129">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:ga2ffdb972f88f0263a5779715a51aa129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad191f405a4c47ca81c9269973b07849f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gad191f405a4c47ca81c9269973b07849f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad191f405a4c47ca81c9269973b07849f">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:gad191f405a4c47ca81c9269973b07849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142c510c60e0008408802ee837989823"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga142c510c60e0008408802ee837989823"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga142c510c60e0008408802ee837989823">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:ga142c510c60e0008408802ee837989823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2833b337ecf27be95e379f054c3992"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9a2833b337ecf27be95e379f054c3992">mbed::Callback&lt; R(A0, A1, A2)&gt;::~Callback</a> ()</td></tr>
<tr class="separator:ga9a2833b337ecf27be95e379f054c3992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ca78ed9faf734c6f6e78d2f5d85dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (R(*func)(A0, A1, A2))</td></tr>
<tr class="separator:ga04ca78ed9faf734c6f6e78d2f5d85dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0b585fc134202df5f42d100f6a0a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3b0b585fc134202df5f42d100f6a0a1a">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;func)</td></tr>
<tr class="separator:ga3b0b585fc134202df5f42d100f6a0a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8fd7e6376db7524ef09994bd7f9efd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7c8fd7e6376db7524ef09994bd7f9efd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7c8fd7e6376db7524ef09994bd7f9efd">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (U *obj, R(T::*method)(A0, A1, A2))</td></tr>
<tr class="separator:ga7c8fd7e6376db7524ef09994bd7f9efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6329fa274e1d2dda2ed5dfda29ac98b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac6329fa274e1d2dda2ed5dfda29ac98b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac6329fa274e1d2dda2ed5dfda29ac98b">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (const U *obj, R(T::*method)(A0, A1, A2) const)</td></tr>
<tr class="separator:gac6329fa274e1d2dda2ed5dfda29ac98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3211275a90e584c82ba71739d4df51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaba3211275a90e584c82ba71739d4df51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaba3211275a90e584c82ba71739d4df51">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (volatile U *obj, R(T::*method)(A0, A1, A2) volatile)</td></tr>
<tr class="separator:gaba3211275a90e584c82ba71739d4df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc502f86dd2b43c2478bd7ebdf835857"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabc502f86dd2b43c2478bd7ebdf835857"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabc502f86dd2b43c2478bd7ebdf835857">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (const volatile U *obj, R(T::*method)(A0, A1, A2) const volatile)</td></tr>
<tr class="separator:gabc502f86dd2b43c2478bd7ebdf835857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c0dcf2934f27ba6552cc5ffd69eb7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga80c0dcf2934f27ba6552cc5ffd69eb7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga80c0dcf2934f27ba6552cc5ffd69eb7b">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (R(*func)(T *, A0, A1, A2), U *arg)</td></tr>
<tr class="separator:ga80c0dcf2934f27ba6552cc5ffd69eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d7519564ac923795f8e6bd4328c8fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gad5d7519564ac923795f8e6bd4328c8fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad5d7519564ac923795f8e6bd4328c8fe">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (R(*func)(const T *, A0, A1, A2), const U *arg)</td></tr>
<tr class="separator:gad5d7519564ac923795f8e6bd4328c8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d3952588e88280c679af21469e6664"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac8d3952588e88280c679af21469e6664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac8d3952588e88280c679af21469e6664">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (R(*func)(volatile T *, A0, A1, A2), volatile U *arg)</td></tr>
<tr class="separator:gac8d3952588e88280c679af21469e6664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165dfd87c2d268a2133e1d79a460aa33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga165dfd87c2d268a2133e1d79a460aa33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga165dfd87c2d268a2133e1d79a460aa33">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (R(*func)(const volatile T *, A0, A1, A2), const volatile U *arg)</td></tr>
<tr class="separator:ga165dfd87c2d268a2133e1d79a460aa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b60eca4b40e0852d737c190e5ac136"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:gad3b60eca4b40e0852d737c190e5ac136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad3b60eca4b40e0852d737c190e5ac136">mbed::Callback&lt; R(A0, A1, A2)&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:gad3b60eca4b40e0852d737c190e5ac136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca0bf587a34ccd9c93554871d17ca74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabca0bf587a34ccd9c93554871d17ca74"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabca0bf587a34ccd9c93554871d17ca74">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(U *obj</td></tr>
<tr class="separator:gabca0bf587a34ccd9c93554871d17ca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f104f47ab5e34a0662f2194daebb58e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4f104f47ab5e34a0662f2194daebb58e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4f104f47ab5e34a0662f2194daebb58e">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(const U *obj</td></tr>
<tr class="separator:ga4f104f47ab5e34a0662f2194daebb58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1188d5e327185d5401d30a9f67a8807e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1188d5e327185d5401d30a9f67a8807e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1188d5e327185d5401d30a9f67a8807e">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(volatile U *obj</td></tr>
<tr class="separator:ga1188d5e327185d5401d30a9f67a8807e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea2ec1cd60c18a08927aa6e29a1d5df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaaea2ec1cd60c18a08927aa6e29a1d5df"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaaea2ec1cd60c18a08927aa6e29a1d5df">mbed::Callback&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:gaaea2ec1cd60c18a08927aa6e29a1d5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ed0d9da8cff05bd66ef3e9a077a427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gae9ed0d9da8cff05bd66ef3e9a077a427">mbed::Callback&lt; R(A0, A1, A2)&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:gae9ed0d9da8cff05bd66ef3e9a077a427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c512a11572d633801561f040bc2a4ee"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0c512a11572d633801561f040bc2a4ee">mbed::Callback&lt; R(A0, A1, A2)&gt;::call</a> (A0 a0, A1 a1, A2 a2) const</td></tr>
<tr class="separator:ga0c512a11572d633801561f040bc2a4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119bb8263bae8c52998a379803ce52de"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga119bb8263bae8c52998a379803ce52de">mbed::Callback&lt; R(A0, A1, A2)&gt;::operator()</a> (A0 a0, A1 a1, A2 a2) const</td></tr>
<tr class="separator:ga119bb8263bae8c52998a379803ce52de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e580fde2c3a9ceea3d8b2025867e65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga88e580fde2c3a9ceea3d8b2025867e65">mbed::Callback&lt; R(A0, A1, A2)&gt;::operator bool</a> () const</td></tr>
<tr class="separator:ga88e580fde2c3a9ceea3d8b2025867e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc4d93ca23dd7a546667857a6a8789a"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1fc4d93ca23dd7a546667857a6a8789a">mbed::Callback&lt; R(A0, A1, A2)&gt;::thunk</a> (void *func, A0 a0, A1 a1, A2 a2)</td></tr>
<tr class="separator:ga1fc4d93ca23dd7a546667857a6a8789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318c3dfcd1f8dd7293e3d3a9bd36bcc7"><td class="memItemLeft" align="right" valign="top"><a id="ga318c3dfcd1f8dd7293e3d3a9bd36bcc7" name="ga318c3dfcd1f8dd7293e3d3a9bd36bcc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:ga318c3dfcd1f8dd7293e3d3a9bd36bcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0490870b941b4fea69f3f0e9c1de6cd0"><td class="memItemLeft" align="right" valign="top"><a id="ga0490870b941b4fea69f3f0e9c1de6cd0" name="ga0490870b941b4fea69f3f0e9c1de6cd0"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::method_context&lt; O, M &gt;::operator()</b> (A0 a0, A1 a1, A2 a2) const</td></tr>
<tr class="separator:ga0490870b941b4fea69f3f0e9c1de6cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec51a036f792b7de1587ac1d1612247"><td class="memItemLeft" align="right" valign="top"><a id="gaaec51a036f792b7de1587ac1d1612247" name="gaaec51a036f792b7de1587ac1d1612247"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:gaaec51a036f792b7de1587ac1d1612247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe277e0ca1d6788f04d7ce83876c7669"><td class="memItemLeft" align="right" valign="top"><a id="gabe277e0ca1d6788f04d7ce83876c7669" name="gabe277e0ca1d6788f04d7ce83876c7669"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::function_context&lt; F, A &gt;::operator()</b> (A0 a0, A1 a1, A2 a2) const</td></tr>
<tr class="separator:gabe277e0ca1d6788f04d7ce83876c7669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd261da77f5938900df20efcaa2e4f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadcd261da77f5938900df20efcaa2e4f7">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (R(*func)(A0, A1, A2, A3)=0)</td></tr>
<tr class="separator:gadcd261da77f5938900df20efcaa2e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3024fb49d70fa6a9d71f84ef0eb14154"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3024fb49d70fa6a9d71f84ef0eb14154">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;func)</td></tr>
<tr class="separator:ga3024fb49d70fa6a9d71f84ef0eb14154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad199dd0b7f13956dadbd2c78068bbff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaad199dd0b7f13956dadbd2c78068bbff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaad199dd0b7f13956dadbd2c78068bbff">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3))</td></tr>
<tr class="separator:gaad199dd0b7f13956dadbd2c78068bbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b8864a63d3abd3ce1b0e1a17bb2c53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga80b8864a63d3abd3ce1b0e1a17bb2c53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga80b8864a63d3abd3ce1b0e1a17bb2c53">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3) const)</td></tr>
<tr class="separator:ga80b8864a63d3abd3ce1b0e1a17bb2c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbe08f1ab210c7768d5dfb7ca853876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2cbe08f1ab210c7768d5dfb7ca853876"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2cbe08f1ab210c7768d5dfb7ca853876">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3) volatile)</td></tr>
<tr class="separator:ga2cbe08f1ab210c7768d5dfb7ca853876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e9b02fd316395ac94fcd30537b43f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gad5e9b02fd316395ac94fcd30537b43f2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad5e9b02fd316395ac94fcd30537b43f2">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3) const volatile)</td></tr>
<tr class="separator:gad5e9b02fd316395ac94fcd30537b43f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0377b1afb4326b54828761d3a207d2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa0377b1afb4326b54828761d3a207d2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa0377b1afb4326b54828761d3a207d2e">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (R(*func)(T *, A0, A1, A2, A3), U *arg)</td></tr>
<tr class="separator:gaa0377b1afb4326b54828761d3a207d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232dadbf518b40c3fb106f706fd64aa8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga232dadbf518b40c3fb106f706fd64aa8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga232dadbf518b40c3fb106f706fd64aa8">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (R(*func)(const T *, A0, A1, A2, A3), const U *arg)</td></tr>
<tr class="separator:ga232dadbf518b40c3fb106f706fd64aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa2c6a75d7eb0651b285661454870e5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2aa2c6a75d7eb0651b285661454870e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2aa2c6a75d7eb0651b285661454870e5">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (R(*func)(volatile T *, A0, A1, A2, A3), volatile U *arg)</td></tr>
<tr class="separator:ga2aa2c6a75d7eb0651b285661454870e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15109359d3989205c2f8e1cf740c7805"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga15109359d3989205c2f8e1cf740c7805"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga15109359d3989205c2f8e1cf740c7805">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3), const volatile U *arg)</td></tr>
<tr class="separator:ga15109359d3989205c2f8e1cf740c7805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29be6d1c7bcc02e82df24fffd018ebc"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:gad29be6d1c7bcc02e82df24fffd018ebc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad29be6d1c7bcc02e82df24fffd018ebc">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2, A3), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:gad29be6d1c7bcc02e82df24fffd018ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50b0d4161c6bd0708a0d57bcfe41a2e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac50b0d4161c6bd0708a0d57bcfe41a2e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac50b0d4161c6bd0708a0d57bcfe41a2e">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:gac50b0d4161c6bd0708a0d57bcfe41a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcf9ce35a49f94f07c221595feaddfb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gadfcf9ce35a49f94f07c221595feaddfb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gadfcf9ce35a49f94f07c221595feaddfb">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:gadfcf9ce35a49f94f07c221595feaddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7ba95f6b6ba83aacf25f853284ef38"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0d7ba95f6b6ba83aacf25f853284ef38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0d7ba95f6b6ba83aacf25f853284ef38">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:ga0d7ba95f6b6ba83aacf25f853284ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54306aa2ec5084666acf90896903eb43"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga54306aa2ec5084666acf90896903eb43"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga54306aa2ec5084666acf90896903eb43">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:ga54306aa2ec5084666acf90896903eb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab02b94fa63b644583ca0a9140998e563"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab02b94fa63b644583ca0a9140998e563">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::~Callback</a> ()</td></tr>
<tr class="separator:gab02b94fa63b644583ca0a9140998e563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313f9560bc2f37a8e26f3d34e281d567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (R(*func)(A0, A1, A2, A3))</td></tr>
<tr class="separator:ga313f9560bc2f37a8e26f3d34e281d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531eafe0e6fa40139a01481e7e290877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga531eafe0e6fa40139a01481e7e290877">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;func)</td></tr>
<tr class="separator:ga531eafe0e6fa40139a01481e7e290877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66aa8dca34b48d1bb59f114503c809fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga66aa8dca34b48d1bb59f114503c809fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga66aa8dca34b48d1bb59f114503c809fe">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (U *obj, R(T::*method)(A0, A1, A2, A3))</td></tr>
<tr class="separator:ga66aa8dca34b48d1bb59f114503c809fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7354e51ff36445585f6bf48aec2a28f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7354e51ff36445585f6bf48aec2a28f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7354e51ff36445585f6bf48aec2a28f6">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (const U *obj, R(T::*method)(A0, A1, A2, A3) const)</td></tr>
<tr class="separator:ga7354e51ff36445585f6bf48aec2a28f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9914b7beed57dca631fcae4a3762e68e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9914b7beed57dca631fcae4a3762e68e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9914b7beed57dca631fcae4a3762e68e">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3) volatile)</td></tr>
<tr class="separator:ga9914b7beed57dca631fcae4a3762e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66e9bf78026c1ba877b0c44f53e9a4c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab66e9bf78026c1ba877b0c44f53e9a4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab66e9bf78026c1ba877b0c44f53e9a4c">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3) const volatile)</td></tr>
<tr class="separator:gab66e9bf78026c1ba877b0c44f53e9a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaeb7feeb8dbaa6e064ec64a47f483d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabaeb7feeb8dbaa6e064ec64a47f483d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabaeb7feeb8dbaa6e064ec64a47f483d7">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (R(*func)(T *, A0, A1, A2, A3), U *arg)</td></tr>
<tr class="separator:gabaeb7feeb8dbaa6e064ec64a47f483d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a521721d964cbc427b4bec933cef88b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1a521721d964cbc427b4bec933cef88b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1a521721d964cbc427b4bec933cef88b">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (R(*func)(const T *, A0, A1, A2, A3), const U *arg)</td></tr>
<tr class="separator:ga1a521721d964cbc427b4bec933cef88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed923ff4526f8e849bd3158515f8178"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3ed923ff4526f8e849bd3158515f8178"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3ed923ff4526f8e849bd3158515f8178">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (R(*func)(volatile T *, A0, A1, A2, A3), volatile U *arg)</td></tr>
<tr class="separator:ga3ed923ff4526f8e849bd3158515f8178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a1945fd9fdeabf11e1a4b1b497e5f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac1a1945fd9fdeabf11e1a4b1b497e5f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac1a1945fd9fdeabf11e1a4b1b497e5f8">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (R(*func)(const volatile T *, A0, A1, A2, A3), const volatile U *arg)</td></tr>
<tr class="separator:gac1a1945fd9fdeabf11e1a4b1b497e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cac9fb8c162c652eaa65061cda8487"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga58cac9fb8c162c652eaa65061cda8487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga58cac9fb8c162c652eaa65061cda8487">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2, A3), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga58cac9fb8c162c652eaa65061cda8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62d1e789da4a5e711aea048267d76f7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa62d1e789da4a5e711aea048267d76f7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa62d1e789da4a5e711aea048267d76f7">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(U *obj</td></tr>
<tr class="separator:gaa62d1e789da4a5e711aea048267d76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f2da4e71a2bab2ddd4d07b7096210f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga91f2da4e71a2bab2ddd4d07b7096210f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga91f2da4e71a2bab2ddd4d07b7096210f">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(const U *obj</td></tr>
<tr class="separator:ga91f2da4e71a2bab2ddd4d07b7096210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d9baeffb825ae0b048fbc34c2b5df5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga61d9baeffb825ae0b048fbc34c2b5df5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga61d9baeffb825ae0b048fbc34c2b5df5">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(volatile U *obj</td></tr>
<tr class="separator:ga61d9baeffb825ae0b048fbc34c2b5df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f6578d65354617b7252894ed7571b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab4f6578d65354617b7252894ed7571b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab4f6578d65354617b7252894ed7571b4">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:gab4f6578d65354617b7252894ed7571b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c604d2d78f81e1f35be77e804ceb5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7c604d2d78f81e1f35be77e804ceb5a5">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:ga7c604d2d78f81e1f35be77e804ceb5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e440ecbfebd9f45d9a8b777299dcb31"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6e440ecbfebd9f45d9a8b777299dcb31">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::call</a> (A0 a0, A1 a1, A2 a2, A3 a3) const</td></tr>
<tr class="separator:ga6e440ecbfebd9f45d9a8b777299dcb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32df25cf2041abd96db7469260a3db2"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad32df25cf2041abd96db7469260a3db2">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::operator()</a> (A0 a0, A1 a1, A2 a2, A3 a3) const</td></tr>
<tr class="separator:gad32df25cf2041abd96db7469260a3db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd4683deb8f24c6ccc028aab7ff1799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9cd4683deb8f24c6ccc028aab7ff1799">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::operator bool</a> () const</td></tr>
<tr class="separator:ga9cd4683deb8f24c6ccc028aab7ff1799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271ac9bd517738f0ab5008e182dc48f6"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga271ac9bd517738f0ab5008e182dc48f6">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::thunk</a> (void *func, A0 a0, A1 a1, A2 a2, A3 a3)</td></tr>
<tr class="separator:ga271ac9bd517738f0ab5008e182dc48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e268660ed069a2f20c82d6890d3cf66"><td class="memItemLeft" align="right" valign="top"><a id="ga3e268660ed069a2f20c82d6890d3cf66" name="ga3e268660ed069a2f20c82d6890d3cf66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:ga3e268660ed069a2f20c82d6890d3cf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48889aad12cd2b33c620ad3894404c3"><td class="memItemLeft" align="right" valign="top"><a id="gad48889aad12cd2b33c620ad3894404c3" name="gad48889aad12cd2b33c620ad3894404c3"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::method_context&lt; O, M &gt;::operator()</b> (A0 a0, A1 a1, A2 a2, A3 a3) const</td></tr>
<tr class="separator:gad48889aad12cd2b33c620ad3894404c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9153fe197db149a61b9f3eb30312b922"><td class="memItemLeft" align="right" valign="top"><a id="ga9153fe197db149a61b9f3eb30312b922" name="ga9153fe197db149a61b9f3eb30312b922"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:ga9153fe197db149a61b9f3eb30312b922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e8b31b212b9c41281021637ad913a8"><td class="memItemLeft" align="right" valign="top"><a id="gad8e8b31b212b9c41281021637ad913a8" name="gad8e8b31b212b9c41281021637ad913a8"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::function_context&lt; F, A &gt;::operator()</b> (A0 a0, A1 a1, A2 a2, A3 a3) const</td></tr>
<tr class="separator:gad8e8b31b212b9c41281021637ad913a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20825b02c441e6fbf9b8c0da18c63c3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga20825b02c441e6fbf9b8c0da18c63c3b">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (R(*func)(A0, A1, A2, A3, A4)=0)</td></tr>
<tr class="separator:ga20825b02c441e6fbf9b8c0da18c63c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63593f9ee9740ba29b8bb32a9f007f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga63593f9ee9740ba29b8bb32a9f007f06">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;func)</td></tr>
<tr class="separator:ga63593f9ee9740ba29b8bb32a9f007f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae016caa48f77914c69cd880730182c58"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae016caa48f77914c69cd880730182c58"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae016caa48f77914c69cd880730182c58">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gae016caa48f77914c69cd880730182c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d95d821c020357e310d2605592269f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa3d95d821c020357e310d2605592269f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa3d95d821c020357e310d2605592269f">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3, A4) const)</td></tr>
<tr class="separator:gaa3d95d821c020357e310d2605592269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534573cf0c4a7842345e29887005155"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9534573cf0c4a7842345e29887005155"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9534573cf0c4a7842345e29887005155">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) volatile)</td></tr>
<tr class="separator:ga9534573cf0c4a7842345e29887005155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73af2947c97682fc16fc0eb1210c3ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa73af2947c97682fc16fc0eb1210c3ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa73af2947c97682fc16fc0eb1210c3ba">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) const volatile)</td></tr>
<tr class="separator:gaa73af2947c97682fc16fc0eb1210c3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd63df22ffa1ff680e5742ba9004e2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4cd63df22ffa1ff680e5742ba9004e2d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4cd63df22ffa1ff680e5742ba9004e2d">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (R(*func)(T *, A0, A1, A2, A3, A4), U *arg)</td></tr>
<tr class="separator:ga4cd63df22ffa1ff680e5742ba9004e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13dd878d1091bfe82ba95453095c2f0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga13dd878d1091bfe82ba95453095c2f0c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga13dd878d1091bfe82ba95453095c2f0c">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (R(*func)(const T *, A0, A1, A2, A3, A4), const U *arg)</td></tr>
<tr class="separator:ga13dd878d1091bfe82ba95453095c2f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afbf0a4df52cdf67ba4c5e193277008"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7afbf0a4df52cdf67ba4c5e193277008"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7afbf0a4df52cdf67ba4c5e193277008">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (R(*func)(volatile T *, A0, A1, A2, A3, A4), volatile U *arg)</td></tr>
<tr class="separator:ga7afbf0a4df52cdf67ba4c5e193277008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd26c568b29fdc1090ea2a384ba4eb32"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gabd26c568b29fdc1090ea2a384ba4eb32"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabd26c568b29fdc1090ea2a384ba4eb32">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3, A4), const volatile U *arg)</td></tr>
<tr class="separator:gabd26c568b29fdc1090ea2a384ba4eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0ea31a72e122a6dcc03e7f173aa4eb"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga1b0ea31a72e122a6dcc03e7f173aa4eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1b0ea31a72e122a6dcc03e7f173aa4eb">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::Callback</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2, A3, A4), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:ga1b0ea31a72e122a6dcc03e7f173aa4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf531a6ae3477bd58c97f25de9e3d8b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2cf531a6ae3477bd58c97f25de9e3d8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2cf531a6ae3477bd58c97f25de9e3d8b">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(U *obj</td></tr>
<tr class="separator:ga2cf531a6ae3477bd58c97f25de9e3d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24469000cdf4f700a1aa06082240b3f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga24469000cdf4f700a1aa06082240b3f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga24469000cdf4f700a1aa06082240b3f8">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const U *obj</td></tr>
<tr class="separator:ga24469000cdf4f700a1aa06082240b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9b60868a69920a80610a513b7da4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaad9b60868a69920a80610a513b7da4ac"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaad9b60868a69920a80610a513b7da4ac">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(volatile U *obj</td></tr>
<tr class="separator:gaad9b60868a69920a80610a513b7da4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7338fbe9d197903b463eabcc63b3aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafc7338fbe9d197903b463eabcc63b3aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafc7338fbe9d197903b463eabcc63b3aa">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>(func, arg)&quot;) Callback(const volatile U *obj</td></tr>
<tr class="separator:gafc7338fbe9d197903b463eabcc63b3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa628baf42353cd60400252a7a5d3acde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa628baf42353cd60400252a7a5d3acde">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::~Callback</a> ()</td></tr>
<tr class="separator:gaa628baf42353cd60400252a7a5d3acde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905e914bb0d8f98948c3cc670f288536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (R(*func)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga905e914bb0d8f98948c3cc670f288536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b8615214b0e06d1f4806434e689a5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad8b8615214b0e06d1f4806434e689a5e">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;func)</td></tr>
<tr class="separator:gad8b8615214b0e06d1f4806434e689a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf411acad8f46e1fdeaa6c72c64f21e39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf411acad8f46e1fdeaa6c72c64f21e39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf411acad8f46e1fdeaa6c72c64f21e39">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (U *obj, R(T::*method)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gaf411acad8f46e1fdeaa6c72c64f21e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f19afc976cbefdfa087449670fdecd2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8f19afc976cbefdfa087449670fdecd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8f19afc976cbefdfa087449670fdecd2">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (const U *obj, R(T::*method)(A0, A1, A2, A3, A4) const)</td></tr>
<tr class="separator:ga8f19afc976cbefdfa087449670fdecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68cb103db1f567f343609b6cc59d6880"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga68cb103db1f567f343609b6cc59d6880"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga68cb103db1f567f343609b6cc59d6880">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) volatile)</td></tr>
<tr class="separator:ga68cb103db1f567f343609b6cc59d6880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7091296f312f20c7f22a7af6d8d989b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga7091296f312f20c7f22a7af6d8d989b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7091296f312f20c7f22a7af6d8d989b6">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) const volatile)</td></tr>
<tr class="separator:ga7091296f312f20c7f22a7af6d8d989b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb147d2bf5978a86a61ebeb51675d60"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gacbb147d2bf5978a86a61ebeb51675d60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gacbb147d2bf5978a86a61ebeb51675d60">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (R(*func)(T *, A0, A1, A2, A3, A4), U *arg)</td></tr>
<tr class="separator:gacbb147d2bf5978a86a61ebeb51675d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d7145bd6021268c4fb5c2edcca1354"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga08d7145bd6021268c4fb5c2edcca1354"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga08d7145bd6021268c4fb5c2edcca1354">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (R(*func)(const T *, A0, A1, A2, A3, A4), const U *arg)</td></tr>
<tr class="separator:ga08d7145bd6021268c4fb5c2edcca1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa03b46559d7ada0a944aedd88bd4ad5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaaa03b46559d7ada0a944aedd88bd4ad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaaa03b46559d7ada0a944aedd88bd4ad5">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (R(*func)(volatile T *, A0, A1, A2, A3, A4), volatile U *arg)</td></tr>
<tr class="separator:gaaa03b46559d7ada0a944aedd88bd4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5951f1aabd0ff74512f0aee11146e34c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga5951f1aabd0ff74512f0aee11146e34c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5951f1aabd0ff74512f0aee11146e34c">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (R(*func)(const volatile T *, A0, A1, A2, A3, A4), const volatile U *arg)</td></tr>
<tr class="separator:ga5951f1aabd0ff74512f0aee11146e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b5eec69b52d7bd62e9f2b7b2a96dfd"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:gab9b5eec69b52d7bd62e9f2b7b2a96dfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab9b5eec69b52d7bd62e9f2b7b2a96dfd">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::attach</a> (F f, typename <a class="el" href="structmbed_1_1detail_1_1enable__if.html">detail::enable_if</a>&lt; <a class="el" href="structmbed_1_1detail_1_1is__type.html">detail::is_type</a>&lt; R(F::*)(A0, A1, A2, A3, A4), &amp;F::operator()&gt;::value &amp;&amp;sizeof(F)&lt;=sizeof(uintptr_t) &gt;::type=<a class="el" href="structmbed_1_1detail_1_1nil.html">detail::nil</a>())</td></tr>
<tr class="separator:gab9b5eec69b52d7bd62e9f2b7b2a96dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e56772bf13895daa7323379ccf221e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaa9e56772bf13895daa7323379ccf221e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa9e56772bf13895daa7323379ccf221e">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(U *obj</td></tr>
<tr class="separator:gaa9e56772bf13895daa7323379ccf221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e28ee4d18429fcec7e82e7f37dcce89"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga2e28ee4d18429fcec7e82e7f37dcce89"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2e28ee4d18429fcec7e82e7f37dcce89">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(const U *obj</td></tr>
<tr class="separator:ga2e28ee4d18429fcec7e82e7f37dcce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4251837ff1a8dbb52763d9bd3c6bd486"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4251837ff1a8dbb52763d9bd3c6bd486"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4251837ff1a8dbb52763d9bd3c6bd486">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(volatile U *obj</td></tr>
<tr class="separator:ga4251837ff1a8dbb52763d9bd3c6bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73ccefa8e61b7f5ae30dbf2c130a826"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae73ccefa8e61b7f5ae30dbf2c130a826"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae73ccefa8e61b7f5ae30dbf2c130a826">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;) void <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(const volatile U *obj</td></tr>
<tr class="separator:gae73ccefa8e61b7f5ae30dbf2c130a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d9d74d4e1f51a4fcb063ff802bcdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga26d9d74d4e1f51a4fcb063ff802bcdcd">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::operator=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;that)</td></tr>
<tr class="separator:ga26d9d74d4e1f51a4fcb063ff802bcdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf6be00579d82fb9668422ee68b878e"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaacf6be00579d82fb9668422ee68b878e">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::call</a> (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const</td></tr>
<tr class="separator:gaacf6be00579d82fb9668422ee68b878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fe615bfd9ff31aafc643c88b06e719"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa2fe615bfd9ff31aafc643c88b06e719">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::operator()</a> (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const</td></tr>
<tr class="separator:gaa2fe615bfd9ff31aafc643c88b06e719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5c16abdb11e378f69f90b519fcb8c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaed5c16abdb11e378f69f90b519fcb8c2">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::operator bool</a> () const</td></tr>
<tr class="separator:gaed5c16abdb11e378f69f90b519fcb8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8173a82ace566be19aff2576e767868"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac8173a82ace566be19aff2576e767868">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::thunk</a> (void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4)</td></tr>
<tr class="separator:gac8173a82ace566be19aff2576e767868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55aa27b080c3e2ff5bb9bdbc16b6ce1"><td class="memItemLeft" align="right" valign="top"><a id="gaf55aa27b080c3e2ff5bb9bdbc16b6ce1" name="gaf55aa27b080c3e2ff5bb9bdbc16b6ce1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::method_context&lt; O, M &gt;::method_context</b> (O *obj, M method)</td></tr>
<tr class="separator:gaf55aa27b080c3e2ff5bb9bdbc16b6ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2deb0ab90d2fcc9cf17b4a8aa7e603"><td class="memItemLeft" align="right" valign="top"><a id="ga1e2deb0ab90d2fcc9cf17b4a8aa7e603" name="ga1e2deb0ab90d2fcc9cf17b4a8aa7e603"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::method_context&lt; O, M &gt;::operator()</b> (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const</td></tr>
<tr class="separator:ga1e2deb0ab90d2fcc9cf17b4a8aa7e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2022a4a4a62cf98d6b4a02725062c5"><td class="memItemLeft" align="right" valign="top"><a id="gabe2022a4a4a62cf98d6b4a02725062c5" name="gabe2022a4a4a62cf98d6b4a02725062c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::function_context&lt; F, A &gt;::function_context</b> (F func, A *arg)</td></tr>
<tr class="separator:gabe2022a4a4a62cf98d6b4a02725062c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd562415968847270c5fc8b1a150a99"><td class="memItemLeft" align="right" valign="top"><a id="ga6bd562415968847270c5fc8b1a150a99" name="ga6bd562415968847270c5fc8b1a150a99"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::function_context&lt; F, A &gt;::operator()</b> (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const</td></tr>
<tr class="separator:ga6bd562415968847270c5fc8b1a150a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79787577174689d1c0c7be04b08fc1d7"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga79787577174689d1c0c7be04b08fc1d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga79787577174689d1c0c7be04b08fc1d7">mbed::callback</a> (R(*func)()=0)</td></tr>
<tr class="separator:ga79787577174689d1c0c7be04b08fc1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1701ad270d60caefefbab76f68d1760c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga1701ad270d60caefefbab76f68d1760c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1701ad270d60caefefbab76f68d1760c">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;func)</td></tr>
<tr class="separator:ga1701ad270d60caefefbab76f68d1760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56bd70769446943c650be3871120c17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gaa56bd70769446943c650be3871120c17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa56bd70769446943c650be3871120c17">mbed::callback</a> (U *obj, R(T::*method)())</td></tr>
<tr class="separator:gaa56bd70769446943c650be3871120c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd90bf037410272a91c23963962210c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga0cd90bf037410272a91c23963962210c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0cd90bf037410272a91c23963962210c">mbed::callback</a> (const U *obj, R(T::*method)() const)</td></tr>
<tr class="separator:ga0cd90bf037410272a91c23963962210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ed43c201888cf9062330471480bf34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga69ed43c201888cf9062330471480bf34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga69ed43c201888cf9062330471480bf34">mbed::callback</a> (volatile U *obj, R(T::*method)() volatile)</td></tr>
<tr class="separator:ga69ed43c201888cf9062330471480bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b4017ed78bafecd9536c407369013f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga15b4017ed78bafecd9536c407369013f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga15b4017ed78bafecd9536c407369013f">mbed::callback</a> (const volatile U *obj, R(T::*method)() const volatile)</td></tr>
<tr class="separator:ga15b4017ed78bafecd9536c407369013f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga071229ea2c15481c2cb6a48fc9dbd2a8">mbed::callback</a> (R(*func)(T *), U *arg)</td></tr>
<tr class="separator:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3f21d279de2bef76e93b3af4a2bb59c8">mbed::callback</a> (R(*func)(const T *), const U *arg)</td></tr>
<tr class="separator:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaae3ca2401eb8ba233f15006d7f87ee6a">mbed::callback</a> (R(*func)(volatile T *), volatile U *arg)</td></tr>
<tr class="separator:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e3ad3a0bf803414400c4016a07becf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga31e3ad3a0bf803414400c4016a07becf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga31e3ad3a0bf803414400c4016a07becf">mbed::callback</a> (R(*func)(const volatile T *), const volatile U *arg)</td></tr>
<tr class="separator:ga31e3ad3a0bf803414400c4016a07becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga598e97b15c4d90f94aa1d1668d5cdcd0">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R()&gt; callback(U *obj</td></tr>
<tr class="separator:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa42c34c97ac84ef443c927ee60afbc1d">mbed::callback</a> (R(*func)(A0)=0)</td></tr>
<tr class="separator:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc57193c9e173b581700c39cb78627c0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gabc57193c9e173b581700c39cb78627c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gabc57193c9e173b581700c39cb78627c0">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;func)</td></tr>
<tr class="separator:gabc57193c9e173b581700c39cb78627c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga22e9edd2ec8c4a38d3d81b13d8dc8dc5">mbed::callback</a> (U *obj, R(T::*method)(A0))</td></tr>
<tr class="separator:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6d698cd8d3988327e040be760ebacf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga9e6d698cd8d3988327e040be760ebacf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9e6d698cd8d3988327e040be760ebacf">mbed::callback</a> (const U *obj, R(T::*method)(A0) const)</td></tr>
<tr class="separator:ga9e6d698cd8d3988327e040be760ebacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga555e63c5df84b0cfff5f07cfbdb9502f">mbed::callback</a> (volatile U *obj, R(T::*method)(A0) volatile)</td></tr>
<tr class="separator:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0f1a4a142d0661b630a3f8e98ca1f902">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0) const volatile)</td></tr>
<tr class="separator:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1b818e85af8edc98cbac8f8645fbb848">mbed::callback</a> (R(*func)(T *, A0), U *arg)</td></tr>
<tr class="separator:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258dc35a2d68be58f584376542df16be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga258dc35a2d68be58f584376542df16be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga258dc35a2d68be58f584376542df16be">mbed::callback</a> (R(*func)(const T *, A0), const U *arg)</td></tr>
<tr class="separator:ga258dc35a2d68be58f584376542df16be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad733151963f94f8ff104fe600640465f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gad733151963f94f8ff104fe600640465f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad733151963f94f8ff104fe600640465f">mbed::callback</a> (R(*func)(volatile T *, A0), volatile U *arg)</td></tr>
<tr class="separator:gad733151963f94f8ff104fe600640465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585bd1d191125de31151106e9e69b407"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga585bd1d191125de31151106e9e69b407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga585bd1d191125de31151106e9e69b407">mbed::callback</a> (R(*func)(const volatile T *, A0), const volatile U *arg)</td></tr>
<tr class="separator:ga585bd1d191125de31151106e9e69b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga301526d02ad11b9014ffd1e03bc577b9">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0)&gt; callback(U *obj</td></tr>
<tr class="separator:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd4e7d3b013591d25525ff29714651e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga9fd4e7d3b013591d25525ff29714651e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9fd4e7d3b013591d25525ff29714651e">mbed::callback</a> (R(*func)(A0, A1)=0)</td></tr>
<tr class="separator:ga9fd4e7d3b013591d25525ff29714651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38777cfe4734cf78af9db263d55be972"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga38777cfe4734cf78af9db263d55be972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga38777cfe4734cf78af9db263d55be972">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;func)</td></tr>
<tr class="separator:ga38777cfe4734cf78af9db263d55be972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249bfa303889a67671725a58ffb975fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga249bfa303889a67671725a58ffb975fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga249bfa303889a67671725a58ffb975fb">mbed::callback</a> (U *obj, R(T::*method)(A0, A1))</td></tr>
<tr class="separator:ga249bfa303889a67671725a58ffb975fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae30b7f1f64e1b15b485a60f2b8de7fc9">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1) const)</td></tr>
<tr class="separator:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga0a07ae1a7775c694f82595ad4da5fabf">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1) volatile)</td></tr>
<tr class="separator:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed87179a6287c3413f31e886b0745a9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gaed87179a6287c3413f31e886b0745a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaed87179a6287c3413f31e886b0745a9c">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1) const volatile)</td></tr>
<tr class="separator:gaed87179a6287c3413f31e886b0745a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2ad466e7f91058dea8c57aef27ff40c9">mbed::callback</a> (R(*func)(T *, A0, A1), U *arg)</td></tr>
<tr class="separator:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3472e49b56c143cf6d221f783983cb82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga3472e49b56c143cf6d221f783983cb82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3472e49b56c143cf6d221f783983cb82">mbed::callback</a> (R(*func)(const T *, A0, A1), const U *arg)</td></tr>
<tr class="separator:ga3472e49b56c143cf6d221f783983cb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gac16c56c90ed9b15dddbc92b5f9d7c637">mbed::callback</a> (R(*func)(volatile T *, A0, A1), volatile U *arg)</td></tr>
<tr class="separator:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1e6237c2220c9df4ad188a3e6550647b">mbed::callback</a> (R(*func)(const volatile T *, A0, A1), const volatile U *arg)</td></tr>
<tr class="separator:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga44f9e781941d03580345c71175307b53">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga44f9e781941d03580345c71175307b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memItemLeft" align="right" valign="top"><a id="ga6a79d55a32e1d1ae294e9b3d3b72c823" name="ga6a79d55a32e1d1ae294e9b3d3b72c823"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1))</td></tr>
<tr class="separator:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdb16e4589e501b95b00aa6404046f4"><td class="memItemLeft" align="right" valign="top"><a id="gabbdb16e4589e501b95b00aa6404046f4" name="gabbdb16e4589e501b95b00aa6404046f4"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1))</td></tr>
<tr class="separator:gabbdb16e4589e501b95b00aa6404046f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memItemLeft" align="right" valign="top"><a id="ga6e6268b0371ee9d06de1ecb0871c7415" name="ga6e6268b0371ee9d06de1ecb0871c7415"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1))</td></tr>
<tr class="separator:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memItemLeft" align="right" valign="top"><a id="ga86fe08eb53a158beb1422d0cf86cb855" name="ga86fe08eb53a158beb1422d0cf86cb855"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1))</td></tr>
<tr class="separator:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga893c318fb8c3b8b7210c7af76e909ae6">mbed::callback</a> (R(*func)(A0, A1, A2)=0)</td></tr>
<tr class="separator:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7d5528182a981ff04f6977d6e2d76a93">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;func)</td></tr>
<tr class="separator:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd68cc0f404703de25bca4121852215"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga4dd68cc0f404703de25bca4121852215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4dd68cc0f404703de25bca4121852215">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2))</td></tr>
<tr class="separator:ga4dd68cc0f404703de25bca4121852215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06aaededf3704033212f2974ad5fb87"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gae06aaededf3704033212f2974ad5fb87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae06aaededf3704033212f2974ad5fb87">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2) const)</td></tr>
<tr class="separator:gae06aaededf3704033212f2974ad5fb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab67ac071dd83fcfa7dca895334fd7d62">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2) volatile)</td></tr>
<tr class="separator:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga95e9ae992de24e6dc0dbd554634030cc">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2) const volatile)</td></tr>
<tr class="separator:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52516fa0337ec89d24f35783562da21"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gad52516fa0337ec89d24f35783562da21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gad52516fa0337ec89d24f35783562da21">mbed::callback</a> (R(*func)(T *, A0, A1, A2), U *arg)</td></tr>
<tr class="separator:gad52516fa0337ec89d24f35783562da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga886aa59ea250bb96e7fc66974b99045a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga886aa59ea250bb96e7fc66974b99045a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga886aa59ea250bb96e7fc66974b99045a">mbed::callback</a> (R(*func)(const T *, A0, A1, A2), const U *arg)</td></tr>
<tr class="separator:ga886aa59ea250bb96e7fc66974b99045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaaf8977070245ca4b6f889ee9c6f98272">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2), volatile U *arg)</td></tr>
<tr class="separator:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19ad8730eba2e5d12f41bcf588b06a5c">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2), const volatile U *arg)</td></tr>
<tr class="separator:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga10bb79c4ef863bc9917cbf446d7d0568">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd464801649c6ff71316ed2373a66f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7fd464801649c6ff71316ed2373a66f1" name="ga7fd464801649c6ff71316ed2373a66f1"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2))</td></tr>
<tr class="separator:ga7fd464801649c6ff71316ed2373a66f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd770ad119c87748e4ed14af62840a3c"><td class="memItemLeft" align="right" valign="top"><a id="gabd770ad119c87748e4ed14af62840a3c" name="gabd770ad119c87748e4ed14af62840a3c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2))</td></tr>
<tr class="separator:gabd770ad119c87748e4ed14af62840a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memItemLeft" align="right" valign="top"><a id="ga1eb0875e7ccc615234c1179bf5ef9907" name="ga1eb0875e7ccc615234c1179bf5ef9907"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memItemLeft" align="right" valign="top"><a id="ga415e35bf19000e3e1a297e2b6dd4c33c" name="ga415e35bf19000e3e1a297e2b6dd4c33c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956f7b22c272c4573f48d56d82a75610"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga956f7b22c272c4573f48d56d82a75610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga956f7b22c272c4573f48d56d82a75610">mbed::callback</a> (R(*func)(A0, A1, A2, A3)=0)</td></tr>
<tr class="separator:ga956f7b22c272c4573f48d56d82a75610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga33bd6f7ae4bbedb4e6736662b2d3e086">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;func)</td></tr>
<tr class="separator:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gadf69fc2a2c3bf9b8ea95259b568e4c45">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3))</td></tr>
<tr class="separator:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcec10bfd9c27c41399bed7785339e52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gafcec10bfd9c27c41399bed7785339e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafcec10bfd9c27c41399bed7785339e52">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3) const)</td></tr>
<tr class="separator:gafcec10bfd9c27c41399bed7785339e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gafe12e4221e4d09ed112f0c88e2dacb12">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3) volatile)</td></tr>
<tr class="separator:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae1ba70adb8e3e79de7fb7b05c2894655">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3) const volatile)</td></tr>
<tr class="separator:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467859b73e3d8d6629943b983734c20b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga467859b73e3d8d6629943b983734c20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga467859b73e3d8d6629943b983734c20b">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3), U *arg)</td></tr>
<tr class="separator:ga467859b73e3d8d6629943b983734c20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9425abebc78baae3a470f5abd501fbd1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga9425abebc78baae3a470f5abd501fbd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9425abebc78baae3a470f5abd501fbd1">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3), const U *arg)</td></tr>
<tr class="separator:ga9425abebc78baae3a470f5abd501fbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684fc9526d04b2b95cde07200cae8aec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga684fc9526d04b2b95cde07200cae8aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga684fc9526d04b2b95cde07200cae8aec">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3), volatile U *arg)</td></tr>
<tr class="separator:ga684fc9526d04b2b95cde07200cae8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga48a08cdd23defe7e16283edf0b1f0c9e">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3), const volatile U *arg)</td></tr>
<tr class="separator:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gae58d69f185c10e920930a5dd1aebeca4">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:gae58d69f185c10e920930a5dd1aebeca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25161621af1037bf51ab84016adc41e6"><td class="memItemLeft" align="right" valign="top"><a id="ga25161621af1037bf51ab84016adc41e6" name="ga25161621af1037bf51ab84016adc41e6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga25161621af1037bf51ab84016adc41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memItemLeft" align="right" valign="top"><a id="ga50fd76309106f1205f5fe8d1fb5793f8" name="ga50fd76309106f1205f5fe8d1fb5793f8"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memItemLeft" align="right" valign="top"><a id="gae960785a3b20bb7d11aa116d2ef3159d" name="gae960785a3b20bb7d11aa116d2ef3159d"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memItemLeft" align="right" valign="top"><a id="ga9e9fdd9ee815f90a694fd10622729ae6" name="ga9e9fdd9ee815f90a694fd10622729ae6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61814764ae4b4a4802dd47b290da69f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:gab61814764ae4b4a4802dd47b290da69f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gab61814764ae4b4a4802dd47b290da69f">mbed::callback</a> (R(*func)(A0, A1, A2, A3, A4)=0)</td></tr>
<tr class="separator:gab61814764ae4b4a4802dd47b290da69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga85df50dd3a956e552bca6fe4b0f90501">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;func)</td></tr>
<tr class="separator:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga40c8ef76d1ef9ad360c39d1a877895b6">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga633ebeae2024d03038f29e42e6e71bf5">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3, A4) const)</td></tr>
<tr class="separator:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7552a7b7668edfa77c5230504170642a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga7552a7b7668edfa77c5230504170642a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7552a7b7668edfa77c5230504170642a">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) volatile)</td></tr>
<tr class="separator:ga7552a7b7668edfa77c5230504170642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9a50820affd6130c4c4b8932d29ee51d">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) const volatile)</td></tr>
<tr class="separator:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4477f99971a99df425de8905a8cd39bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga4477f99971a99df425de8905a8cd39bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4477f99971a99df425de8905a8cd39bb">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3, A4), U *arg)</td></tr>
<tr class="separator:ga4477f99971a99df425de8905a8cd39bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9ad3f0ce8b1736d861be9c570bf6b1b5">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3, A4), const U *arg)</td></tr>
<tr class="separator:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7a61b2468eb9481fa2f206fef03613b9">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3, A4), volatile U *arg)</td></tr>
<tr class="separator:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga48c9ab82acf82693e1cbedd5efc14933">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3, A4), const volatile U *arg)</td></tr>
<tr class="separator:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga523a7324cf927bf9614efeb64c557d66">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga523a7324cf927bf9614efeb64c557d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memItemLeft" align="right" valign="top"><a id="ga07932813a1b77d4df478f3f4872cd4ff" name="ga07932813a1b77d4df478f3f4872cd4ff"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memItemLeft" align="right" valign="top"><a id="gaf22c19ca6c2ab41c071037ce9c42aa9d" name="gaf22c19ca6c2ab41c071037ce9c42aa9d"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36a23ed73fdb64410841161f07c05dc"><td class="memItemLeft" align="right" valign="top"><a id="gab36a23ed73fdb64410841161f07c05dc" name="gab36a23ed73fdb64410841161f07c05dc"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gab36a23ed73fdb64410841161f07c05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memItemLeft" align="right" valign="top"><a id="gae34aa30f64c3b8fe0bc2d5863bb04164" name="gae34aa30f64c3b8fe0bc2d5863bb04164"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b2b14e23b60c4d81522b19ef04cd9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga01b2b14e23b60c4d81522b19ef04cd9b">mbed::CallChain::CallChain</a> (int <a class="el" href="group__platform.html#ga914b04b74d74f02398f93600e7ec7b27">size</a>=4)</td></tr>
<tr class="separator:ga01b2b14e23b60c4d81522b19ef04cd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19929d1fbe56245a5cf4af62696ec1a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">mbed::CallChain::add</a> (<a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt; func)</td></tr>
<tr class="separator:ga19929d1fbe56245a5cf4af62696ec1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d3c8fc4c6e97a38eb512ef131d631e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M &gt; </td></tr>
<tr class="memitem:gaf7d3c8fc4c6e97a38eb512ef131d631e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf7d3c8fc4c6e97a38eb512ef131d631e">mbed::CallChain::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;The <a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a> function does not support cv-qualifiers. Replaced by &quot; &quot;<a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(callback(obj, method)).&quot;) pFunctionPointer_t <a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(T *obj</td></tr>
<tr class="separator:gaf7d3c8fc4c6e97a38eb512ef131d631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8784da11faa09b23c7e290ce3326d10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">mbed::CallChain::add_front</a> (<a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt; func)</td></tr>
<tr class="separator:ga8784da11faa09b23c7e290ce3326d10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe1c726069fc595b3b669e2b7faef02"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M &gt; </td></tr>
<tr class="memitem:ga7fe1c726069fc595b3b669e2b7faef02"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7fe1c726069fc595b3b669e2b7faef02">mbed::CallChain::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;The <a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a> function does not support cv-qualifiers. Replaced by &quot; &quot;<a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a>(callback(obj, method)).&quot;) pFunctionPointer_t <a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a>(T *obj</td></tr>
<tr class="separator:ga7fe1c726069fc595b3b669e2b7faef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914b04b74d74f02398f93600e7ec7b27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga914b04b74d74f02398f93600e7ec7b27">mbed::CallChain::size</a> () const</td></tr>
<tr class="separator:ga914b04b74d74f02398f93600e7ec7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabea593f2dfc6d6e8dd5bb323eff6adab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabea593f2dfc6d6e8dd5bb323eff6adab">mbed::CallChain::get</a> (int i) const</td></tr>
<tr class="separator:gabea593f2dfc6d6e8dd5bb323eff6adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5881f835f221141fcf49ab9cb9aae5bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5881f835f221141fcf49ab9cb9aae5bd">mbed::CallChain::find</a> (<a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a> f) const</td></tr>
<tr class="separator:ga5881f835f221141fcf49ab9cb9aae5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65693758d2e75e3390e64d27b98556c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga65693758d2e75e3390e64d27b98556c2">mbed::CallChain::clear</a> ()</td></tr>
<tr class="separator:ga65693758d2e75e3390e64d27b98556c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4396b8d6374b95f13c95775bd8e0137a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4396b8d6374b95f13c95775bd8e0137a">mbed::CallChain::remove</a> (<a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a> f)</td></tr>
<tr class="separator:ga4396b8d6374b95f13c95775bd8e0137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac911bd44ea0a14da0b0dd46187bf1081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac911bd44ea0a14da0b0dd46187bf1081">mbed::CallChain::call</a> ()</td></tr>
<tr class="separator:gac911bd44ea0a14da0b0dd46187bf1081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f37349d3cef33c8f27368ef9cdca1c9"><td class="memItemLeft" align="right" valign="top"><a id="ga8f37349d3cef33c8f27368ef9cdca1c9" name="ga8f37349d3cef33c8f27368ef9cdca1c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::CallChain::operator()</b> (void)</td></tr>
<tr class="separator:ga8f37349d3cef33c8f27368ef9cdca1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6dc8818ef840abd656e2863d27af8b0"><td class="memItemLeft" align="right" valign="top"><a id="gad6dc8818ef840abd656e2863d27af8b0" name="gad6dc8818ef840abd656e2863d27af8b0"></a>
<a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::CallChain::operator[]</b> (int i) const</td></tr>
<tr class="separator:gad6dc8818ef840abd656e2863d27af8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7912eb5ef637aee9dec87ccc2c142027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga7912eb5ef637aee9dec87ccc2c142027">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;::push</a> (const T &amp;data)</td></tr>
<tr class="separator:ga7912eb5ef637aee9dec87ccc2c142027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f648bd0c4c64dca2a4549eac41381c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad3f648bd0c4c64dca2a4549eac41381c">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;::pop</a> (T &amp;data)</td></tr>
<tr class="separator:gad3f648bd0c4c64dca2a4549eac41381c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5c033b92daa3d0575702d3f0d9464d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga3d5c033b92daa3d0575702d3f0d9464d">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;::empty</a> ()</td></tr>
<tr class="separator:ga3d5c033b92daa3d0575702d3f0d9464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;::full</a> ()</td></tr>
<tr class="separator:ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa832ce32a966c1605af04e988c273f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaeaa832ce32a966c1605af04e988c273f">mbed::CircularBuffer&lt; T, BufferSize, CounterType &gt;::reset</a> ()</td></tr>
<tr class="separator:gaeaa832ce32a966c1605af04e988c273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e8efe109debaecb97353942640531d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga44e8efe109debaecb97353942640531d">core_util_are_interrupts_enabled</a> (void)</td></tr>
<tr class="separator:ga44e8efe109debaecb97353942640531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d950b3bb0026db2d01df0efd5f18f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga4d950b3bb0026db2d01df0efd5f18f66">core_util_critical_section_enter</a> (void)</td></tr>
<tr class="separator:ga4d950b3bb0026db2d01df0efd5f18f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbfbd322e41f1f0709332af8c3afc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga9fbfbd322e41f1f0709332af8c3afc52">core_util_critical_section_exit</a> (void)</td></tr>
<tr class="separator:ga9fbfbd322e41f1f0709332af8c3afc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2da9a3507c0b348c788ec33a4002427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gad2da9a3507c0b348c788ec33a4002427">core_util_atomic_cas_u8</a> (uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="separator:gad2da9a3507c0b348c788ec33a4002427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dce10ba94bce93c711b9547b33323f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1dce10ba94bce93c711b9547b33323f6">core_util_atomic_cas_u16</a> (uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="separator:ga1dce10ba94bce93c711b9547b33323f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3e2741e98d541f996fa05d64e4f6f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaef3e2741e98d541f996fa05d64e4f6f7">core_util_atomic_cas_u32</a> (uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="separator:gaef3e2741e98d541f996fa05d64e4f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998af6df4c50b0e05397144d3a162ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga998af6df4c50b0e05397144d3a162ce6">core_util_atomic_cas_ptr</a> (void **ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="separator:ga998af6df4c50b0e05397144d3a162ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993f6c456b9518a49bfbb96f19115646"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga993f6c456b9518a49bfbb96f19115646">core_util_atomic_incr_u8</a> (uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:ga993f6c456b9518a49bfbb96f19115646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf639e19faa639bf886a2a7dae8dd5bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadf639e19faa639bf886a2a7dae8dd5bc">core_util_atomic_incr_u16</a> (uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:gadf639e19faa639bf886a2a7dae8dd5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266f82819c467e868a6160cfcff66f20"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga266f82819c467e868a6160cfcff66f20">core_util_atomic_incr_u32</a> (uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:ga266f82819c467e868a6160cfcff66f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332b9bdb03ba39b34dc69d132b80fe8f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga332b9bdb03ba39b34dc69d132b80fe8f">core_util_atomic_incr_ptr</a> (void **valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga332b9bdb03ba39b34dc69d132b80fe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a0c9bc7e4ab8f0d3274c518dc5bcd7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac6a0c9bc7e4ab8f0d3274c518dc5bcd7">core_util_atomic_decr_u8</a> (uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:gac6a0c9bc7e4ab8f0d3274c518dc5bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc455724a1bbdbbdbfb54f2b80887d7c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc455724a1bbdbbdbfb54f2b80887d7c">core_util_atomic_decr_u16</a> (uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:gadc455724a1bbdbbdbfb54f2b80887d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347c5567d9e5fcc04c9ffa62acecac7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga347c5567d9e5fcc04c9ffa62acecac7d">core_util_atomic_decr_u32</a> (uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:ga347c5567d9e5fcc04c9ffa62acecac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839a89f0bd3f1a3227ed7771be1f1b29"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga839a89f0bd3f1a3227ed7771be1f1b29">core_util_atomic_decr_ptr</a> (void **valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga839a89f0bd3f1a3227ed7771be1f1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3f019f341fc690251f9cda4fb212d1"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3f019f341fc690251f9cda4fb212d1" name="ga8e3f019f341fc690251f9cda4fb212d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::MBED_DEPRECATED_SINCE</b> (&quot;mbed-os-5.1&quot;, &quot;<a class="el" href="classmbed_1_1_function_pointer_arg1.html">FunctionPointerArg1</a>&lt;R, A&gt; has been replaced by <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A)&gt;&quot;) FunctionPointerArg1(R(*function)(A1)=0)</td></tr>
<tr class="separator:ga8e3f019f341fc690251f9cda4fb212d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b362867234677bd9def81e88abfd4b"><td class="memTemplParams" colspan="2"><a id="ga72b362867234677bd9def81e88abfd4b" name="ga72b362867234677bd9def81e88abfd4b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72b362867234677bd9def81e88abfd4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::MBED_DEPRECATED_SINCE</b> (&quot;mbed-os-5.1&quot;, &quot;<a class="el" href="classmbed_1_1_function_pointer_arg1.html">FunctionPointerArg1</a>&lt;R, A&gt; has been replaced by <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A)&gt;&quot;) FunctionPointerArg1(T *object</td></tr>
<tr class="separator:ga72b362867234677bd9def81e88abfd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706c376a4c6937fee2ee2bde04175192"><td class="memItemLeft" align="right" valign="top"><a id="ga706c376a4c6937fee2ee2bde04175192" name="ga706c376a4c6937fee2ee2bde04175192"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::call</b> (A1 a1) const</td></tr>
<tr class="separator:ga706c376a4c6937fee2ee2bde04175192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2646d261bae58e24fdb9b320c86b0a93"><td class="memItemLeft" align="right" valign="top"><a id="ga2646d261bae58e24fdb9b320c86b0a93" name="ga2646d261bae58e24fdb9b320c86b0a93"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::operator()</b> (A1 a1) const</td></tr>
<tr class="separator:ga2646d261bae58e24fdb9b320c86b0a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58a25bd1cd7ac8072c666a89ab5c589c"><td class="memItemLeft" align="right" valign="top"><a id="ga58a25bd1cd7ac8072c666a89ab5c589c" name="ga58a25bd1cd7ac8072c666a89ab5c589c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::MBED_DEPRECATED_SINCE</b> (&quot;mbed-os-5.1&quot;, &quot;<a class="el" href="classmbed_1_1_function_pointer_arg1.html">FunctionPointer</a> has been replaced by <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;void()&gt;&quot;) FunctionPointerArg1(R(*function)()=0)</td></tr>
<tr class="separator:ga58a25bd1cd7ac8072c666a89ab5c589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeed5848b3c4695b2730ee37105db6e"><td class="memTemplParams" colspan="2"><a id="gafbeed5848b3c4695b2730ee37105db6e" name="gafbeed5848b3c4695b2730ee37105db6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafbeed5848b3c4695b2730ee37105db6e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::MBED_DEPRECATED_SINCE</b> (&quot;mbed-os-5.1&quot;, &quot;<a class="el" href="classmbed_1_1_function_pointer_arg1.html">FunctionPointer</a> has been replaced by <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;void()&gt;&quot;) FunctionPointerArg1(T *object</td></tr>
<tr class="separator:gafbeed5848b3c4695b2730ee37105db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9955daa4a8b326479969063e9895620b"><td class="memItemLeft" align="right" valign="top"><a id="ga9955daa4a8b326479969063e9895620b" name="ga9955daa4a8b326479969063e9895620b"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::call</b> () const</td></tr>
<tr class="separator:ga9955daa4a8b326479969063e9895620b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2163839a61b6a3a7693e928cbc40e30f"><td class="memItemLeft" align="right" valign="top"><a id="ga2163839a61b6a3a7693e928cbc40e30f" name="ga2163839a61b6a3a7693e928cbc40e30f"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::operator()</b> () const</td></tr>
<tr class="separator:ga2163839a61b6a3a7693e928cbc40e30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541eb099008f2c2c095391db5ecb6713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga541eb099008f2c2c095391db5ecb6713">mbed_assert_internal</a> (const char *expr, const char *file, int line)</td></tr>
<tr class="separator:ga541eb099008f2c2c095391db5ecb6713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e34b12eea1c3ad7258231bcf98121b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga03e34b12eea1c3ad7258231bcf98121b">mbed_mac_address</a> (char *mac)</td></tr>
<tr class="separator:ga03e34b12eea1c3ad7258231bcf98121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539c73852cd4510b6bf5319d8b4c46d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga539c73852cd4510b6bf5319d8b4c46d2">mbed_die</a> (void)</td></tr>
<tr class="separator:ga539c73852cd4510b6bf5319d8b4c46d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3dda312f4b7366c6715eea49b7205b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga6a3dda312f4b7366c6715eea49b7205b">mbed_error_printf</a> (const char *format,...)</td></tr>
<tr class="separator:ga6a3dda312f4b7366c6715eea49b7205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac932c58d3618aa41d3f0647325b718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabac932c58d3618aa41d3f0647325b718">mbed_error_vfprintf</a> (const char *format, va_list arg)</td></tr>
<tr class="separator:gabac932c58d3618aa41d3f0647325b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c5e4dcae473130cdb63f963642943c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaf9c5e4dcae473130cdb63f963642943c">mbed_mem_trace_set_callback</a> (<a class="el" href="group__platform.html#ga41b05bedaf7cb911c344087b8449642e">mbed_mem_trace_cb_t</a> cb)</td></tr>
<tr class="separator:gaf9c5e4dcae473130cdb63f963642943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a705b4981fc2deab12a6680ecdacf17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga1a705b4981fc2deab12a6680ecdacf17">mbed_mem_trace_malloc</a> (void *res, size_t size, void *caller)</td></tr>
<tr class="separator:ga1a705b4981fc2deab12a6680ecdacf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe6cd853e485351fbe6a16f91db7815"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadbe6cd853e485351fbe6a16f91db7815">mbed_mem_trace_realloc</a> (void *res, void *ptr, size_t size, void *caller)</td></tr>
<tr class="separator:gadbe6cd853e485351fbe6a16f91db7815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c1213e8b7fb2133884f1cecd8dba55"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga62c1213e8b7fb2133884f1cecd8dba55">mbed_mem_trace_calloc</a> (void *res, size_t num, size_t size, void *caller)</td></tr>
<tr class="separator:ga62c1213e8b7fb2133884f1cecd8dba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f20d537ce904f24b4deb60d69dcc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa5f20d537ce904f24b4deb60d69dcc2a">mbed_mem_trace_free</a> (void *ptr, void *caller)</td></tr>
<tr class="separator:gaa5f20d537ce904f24b4deb60d69dcc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef762d6d738c92a22183c510d44641f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaef762d6d738c92a22183c510d44641f6">mbed_mem_trace_default_callback</a> (uint8_t op, void *res, void *caller,...)</td></tr>
<tr class="separator:gaef762d6d738c92a22183c510d44641f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f630e822fbcf4f6f37f9e4e97bce210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga2f630e822fbcf4f6f37f9e4e97bce210">mbed_stats_heap_get</a> (<a class="el" href="structmbed__stats__heap__t.html">mbed_stats_heap_t</a> *stats)</td></tr>
<tr class="separator:ga2f630e822fbcf4f6f37f9e4e97bce210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab05979e087023e3b4f8c4862943b7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaab05979e087023e3b4f8c4862943b7ad">mbed_stats_stack_get</a> (<a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> *stats)</td></tr>
<tr class="separator:gaab05979e087023e3b4f8c4862943b7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077431ed5998c908c8a7d964a825dc94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga077431ed5998c908c8a7d964a825dc94">mbed_stats_stack_get_each</a> (<a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> *stats, size_t count)</td></tr>
<tr class="separator:ga077431ed5998c908c8a7d964a825dc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1e10825bf4a6ecdd567e9f2f384ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga5d1e10825bf4a6ecdd567e9f2f384ed1">set_time</a> (time_t t)</td></tr>
<tr class="separator:ga5d1e10825bf4a6ecdd567e9f2f384ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb227bab29aeab78f308d091a1d4b7be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaeb227bab29aeab78f308d091a1d4b7be">attach_rtc</a> (time_t(*read_rtc)(void), void(*write_rtc)(time_t), void(*init_rtc)(void), int(*isenabled_rtc)(void))</td></tr>
<tr class="separator:gaeb227bab29aeab78f308d091a1d4b7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f185640162870544484447dddb655f3"><td class="memItemLeft" align="right" valign="top"><a id="ga8f185640162870544484447dddb655f3" name="ga8f185640162870544484447dddb655f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Transaction&lt; Class &gt;::Transaction</b> (Class *tpointer, const <a class="el" href="structmbed_1_1transaction__t.html">transaction_t</a> &amp;transaction)</td></tr>
<tr class="separator:ga8f185640162870544484447dddb655f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d778331549f8485cbea11de1863ab7"><td class="memItemLeft" align="right" valign="top">Class *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab6d778331549f8485cbea11de1863ab7">mbed::Transaction&lt; Class &gt;::get_object</a> ()</td></tr>
<tr class="separator:gab6d778331549f8485cbea11de1863ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25aa48d87dedca391051fb85352f99b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbed_1_1transaction__t.html">transaction_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga25aa48d87dedca391051fb85352f99b1">mbed::Transaction&lt; Class &gt;::get_transaction</a> ()</td></tr>
<tr class="separator:ga25aa48d87dedca391051fb85352f99b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad193c342ba6249a25daa112646b68ed5"><td class="memItemLeft" align="right" valign="top"><a id="gad193c342ba6249a25daa112646b68ed5" name="gad193c342ba6249a25daa112646b68ed5"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::detail::is_type&lt; M, M &gt;::value</b> = true</td></tr>
<tr class="separator:gad193c342ba6249a25daa112646b68ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e872bf429f488aebff9b4e0867fc687"><td class="memItemLeft" align="right" valign="top"><a id="ga8e872bf429f488aebff9b4e0867fc687" name="ga8e872bf429f488aebff9b4e0867fc687"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::func</b> )(T *))</td></tr>
<tr class="separator:ga8e872bf429f488aebff9b4e0867fc687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ef6fb7077259dc50fab07a40808c02"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R()&gt;::_staticfunc</b> )()</td></tr>
<tr class="separator:ga24ef6fb7077259dc50fab07a40808c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393d17529ed078462b044d7d543e7cb2"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R()&gt;::_boundfunc</b> )(_class *)</td></tr>
<tr class="separator:ga393d17529ed078462b044d7d543e7cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b1997df32999bbd0f98e451729c449"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R()&gt;::_methodfunc</b> )()</td></tr>
<tr class="separator:ga20b1997df32999bbd0f98e451729c449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8808b94b84ab841d6a1732b3caaeeb23"><td class="memItemLeft" align="right" valign="top"><a id="ga8808b94b84ab841d6a1732b3caaeeb23" name="ga8808b94b84ab841d6a1732b3caaeeb23"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::ops::call</b> )(const void *)</td></tr>
<tr class="separator:ga8808b94b84ab841d6a1732b3caaeeb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a543b61e0b2c84b30b3ef2ea511f711"><td class="memItemLeft" align="right" valign="top"><a id="ga7a543b61e0b2c84b30b3ef2ea511f711" name="ga7a543b61e0b2c84b30b3ef2ea511f711"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:ga7a543b61e0b2c84b30b3ef2ea511f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877f880b456c6f54d4981b788d8c4656"><td class="memItemLeft" align="right" valign="top"><a id="ga877f880b456c6f54d4981b788d8c4656" name="ga877f880b456c6f54d4981b788d8c4656"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:ga877f880b456c6f54d4981b788d8c4656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ade4591e1763b85f5155ae024d2296"><td class="memItemLeft" align="right" valign="top"><a id="gaa6ade4591e1763b85f5155ae024d2296" name="gaa6ade4591e1763b85f5155ae024d2296"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:gaa6ade4591e1763b85f5155ae024d2296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e729aa448b2cfe2b25af8dd378c75bb"><td class="memItemLeft" align="right" valign="top"><a id="ga0e729aa448b2cfe2b25af8dd378c75bb" name="ga0e729aa448b2cfe2b25af8dd378c75bb"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:ga0e729aa448b2cfe2b25af8dd378c75bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff08059f49984f48ac95d0551b73c22"><td class="memItemLeft" align="right" valign="top"><a id="ga7ff08059f49984f48ac95d0551b73c22" name="ga7ff08059f49984f48ac95d0551b73c22"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:ga7ff08059f49984f48ac95d0551b73c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a42ce73a82900b355f8ea59d52964e7"><td class="memItemLeft" align="right" valign="top"><a id="ga1a42ce73a82900b355f8ea59d52964e7" name="ga1a42ce73a82900b355f8ea59d52964e7"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R()&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga1a42ce73a82900b355f8ea59d52964e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f48d08b413e2882b78f19f446c7722e"><td class="memItemLeft" align="right" valign="top"><a id="ga2f48d08b413e2882b78f19f446c7722e" name="ga2f48d08b413e2882b78f19f446c7722e"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::func</b> )(T *, A0))</td></tr>
<tr class="separator:ga2f48d08b413e2882b78f19f446c7722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cbf160074b4cc58fb825c3eea59ab7"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0)&gt;::_staticfunc</b> )(A0)</td></tr>
<tr class="separator:ga16cbf160074b4cc58fb825c3eea59ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356bc289d07d582a8ecaa9fca32c52b8"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0)&gt;::_boundfunc</b> )(_class *, A0)</td></tr>
<tr class="separator:ga356bc289d07d582a8ecaa9fca32c52b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cc01230fdff0de904def3070ce743e"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0)&gt;::_methodfunc</b> )(A0)</td></tr>
<tr class="separator:ga64cc01230fdff0de904def3070ce743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2483c1c17a018ccbeb383c4165481095"><td class="memItemLeft" align="right" valign="top"><a id="ga2483c1c17a018ccbeb383c4165481095" name="ga2483c1c17a018ccbeb383c4165481095"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::ops::call</b> )(const void *, A0)</td></tr>
<tr class="separator:ga2483c1c17a018ccbeb383c4165481095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182c6ec8cceb1002c7c75d19f85af928"><td class="memItemLeft" align="right" valign="top"><a id="ga182c6ec8cceb1002c7c75d19f85af928" name="ga182c6ec8cceb1002c7c75d19f85af928"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:ga182c6ec8cceb1002c7c75d19f85af928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e103be9a113a3548c6af5d47fecff65"><td class="memItemLeft" align="right" valign="top"><a id="ga3e103be9a113a3548c6af5d47fecff65" name="ga3e103be9a113a3548c6af5d47fecff65"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:ga3e103be9a113a3548c6af5d47fecff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c95036739d766a1ac9259e157722f60"><td class="memItemLeft" align="right" valign="top"><a id="ga4c95036739d766a1ac9259e157722f60" name="ga4c95036739d766a1ac9259e157722f60"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:ga4c95036739d766a1ac9259e157722f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db31ad0e1177a963d3a47cc7162608f"><td class="memItemLeft" align="right" valign="top"><a id="ga9db31ad0e1177a963d3a47cc7162608f" name="ga9db31ad0e1177a963d3a47cc7162608f"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:ga9db31ad0e1177a963d3a47cc7162608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ccea309903ca7baab78c6fdf2d8a08b"><td class="memItemLeft" align="right" valign="top"><a id="ga2ccea309903ca7baab78c6fdf2d8a08b" name="ga2ccea309903ca7baab78c6fdf2d8a08b"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:ga2ccea309903ca7baab78c6fdf2d8a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a10fe1987a486777f00cf1aedcd144d"><td class="memItemLeft" align="right" valign="top"><a id="ga8a10fe1987a486777f00cf1aedcd144d" name="ga8a10fe1987a486777f00cf1aedcd144d"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0)&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga8a10fe1987a486777f00cf1aedcd144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e7ca7179a34402bd945aa58cf21066"><td class="memItemLeft" align="right" valign="top"><a id="gaa9e7ca7179a34402bd945aa58cf21066" name="gaa9e7ca7179a34402bd945aa58cf21066"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::func</b> )(T *, A0, A1))</td></tr>
<tr class="separator:gaa9e7ca7179a34402bd945aa58cf21066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ac6dd5fbeaa3a19327ee5e7722b5b6"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1)&gt;::_staticfunc</b> )(A0, A1)</td></tr>
<tr class="separator:ga73ac6dd5fbeaa3a19327ee5e7722b5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49361957cadbd322f966d92bfdf0482"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1)&gt;::_boundfunc</b> )(_class *, A0, A1)</td></tr>
<tr class="separator:gab49361957cadbd322f966d92bfdf0482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff3c70146fe832a2ab134885bc8a89a"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1)&gt;::_methodfunc</b> )(A0, A1)</td></tr>
<tr class="separator:ga7ff3c70146fe832a2ab134885bc8a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5270eb3c62388ddfdd56b2f36b195721"><td class="memItemLeft" align="right" valign="top"><a id="ga5270eb3c62388ddfdd56b2f36b195721" name="ga5270eb3c62388ddfdd56b2f36b195721"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::ops::call</b> )(const void *, A0, A1)</td></tr>
<tr class="separator:ga5270eb3c62388ddfdd56b2f36b195721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89739f286811a7088a98992598171e4"><td class="memItemLeft" align="right" valign="top"><a id="gad89739f286811a7088a98992598171e4" name="gad89739f286811a7088a98992598171e4"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:gad89739f286811a7088a98992598171e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6793d775d56922695aebef8e0836b4b"><td class="memItemLeft" align="right" valign="top"><a id="gad6793d775d56922695aebef8e0836b4b" name="gad6793d775d56922695aebef8e0836b4b"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:gad6793d775d56922695aebef8e0836b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4210a73cb7f2a6488f5f2b77062f22"><td class="memItemLeft" align="right" valign="top"><a id="ga2f4210a73cb7f2a6488f5f2b77062f22" name="ga2f4210a73cb7f2a6488f5f2b77062f22"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:ga2f4210a73cb7f2a6488f5f2b77062f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadefd0422a6286123b65d9a83efd3643b"><td class="memItemLeft" align="right" valign="top"><a id="gadefd0422a6286123b65d9a83efd3643b" name="gadefd0422a6286123b65d9a83efd3643b"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:gadefd0422a6286123b65d9a83efd3643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e947341946fdff03e6bee2e2499824"><td class="memItemLeft" align="right" valign="top"><a id="gaf4e947341946fdff03e6bee2e2499824" name="gaf4e947341946fdff03e6bee2e2499824"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:gaf4e947341946fdff03e6bee2e2499824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7179174110b166d5de576fbb6021f9d6"><td class="memItemLeft" align="right" valign="top"><a id="ga7179174110b166d5de576fbb6021f9d6" name="ga7179174110b166d5de576fbb6021f9d6"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1)&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga7179174110b166d5de576fbb6021f9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8241ca86bf12e9af9c2af4d7a95edfb"><td class="memItemLeft" align="right" valign="top"><a id="gae8241ca86bf12e9af9c2af4d7a95edfb" name="gae8241ca86bf12e9af9c2af4d7a95edfb"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::func</b> )(T *, A0, A1, A2))</td></tr>
<tr class="separator:gae8241ca86bf12e9af9c2af4d7a95edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f6e3a4fd82f7aa7c60149311e4773d"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2)&gt;::_staticfunc</b> )(A0, A1, A2)</td></tr>
<tr class="separator:ga62f6e3a4fd82f7aa7c60149311e4773d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f18a7810a34139ab00a147df8a32f4"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2)&gt;::_boundfunc</b> )(_class *, A0, A1, A2)</td></tr>
<tr class="separator:gab8f18a7810a34139ab00a147df8a32f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fa794029b3a15a0a24f791b8a8727d"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2)&gt;::_methodfunc</b> )(A0, A1, A2)</td></tr>
<tr class="separator:ga67fa794029b3a15a0a24f791b8a8727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7eb93852dbe11aaf7f6e552bcaeca1"><td class="memItemLeft" align="right" valign="top"><a id="ga1d7eb93852dbe11aaf7f6e552bcaeca1" name="ga1d7eb93852dbe11aaf7f6e552bcaeca1"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::ops::call</b> )(const void *, A0, A1, A2)</td></tr>
<tr class="separator:ga1d7eb93852dbe11aaf7f6e552bcaeca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be2f9aaae9ef5ea02c541a4151cc508"><td class="memItemLeft" align="right" valign="top"><a id="ga9be2f9aaae9ef5ea02c541a4151cc508" name="ga9be2f9aaae9ef5ea02c541a4151cc508"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:ga9be2f9aaae9ef5ea02c541a4151cc508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfa4cf531d1673843b45ae7f01c9dca"><td class="memItemLeft" align="right" valign="top"><a id="ga3cfa4cf531d1673843b45ae7f01c9dca" name="ga3cfa4cf531d1673843b45ae7f01c9dca"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:ga3cfa4cf531d1673843b45ae7f01c9dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b23009873ac1c7711b711999adab73"><td class="memItemLeft" align="right" valign="top"><a id="gaa9b23009873ac1c7711b711999adab73" name="gaa9b23009873ac1c7711b711999adab73"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:gaa9b23009873ac1c7711b711999adab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3870a04ae1c1e0ed4af5f9a5f955ea45"><td class="memItemLeft" align="right" valign="top"><a id="ga3870a04ae1c1e0ed4af5f9a5f955ea45" name="ga3870a04ae1c1e0ed4af5f9a5f955ea45"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:ga3870a04ae1c1e0ed4af5f9a5f955ea45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a39020e342ea1cefebfcd435652277"><td class="memItemLeft" align="right" valign="top"><a id="gac3a39020e342ea1cefebfcd435652277" name="gac3a39020e342ea1cefebfcd435652277"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:gac3a39020e342ea1cefebfcd435652277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e93ae630163653dca837292145278bc"><td class="memItemLeft" align="right" valign="top"><a id="ga3e93ae630163653dca837292145278bc" name="ga3e93ae630163653dca837292145278bc"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2)&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga3e93ae630163653dca837292145278bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcc8be87ddc4ff2bc461c2ecc606ec5"><td class="memItemLeft" align="right" valign="top"><a id="gabdcc8be87ddc4ff2bc461c2ecc606ec5" name="gabdcc8be87ddc4ff2bc461c2ecc606ec5"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::func</b> )(T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:gabdcc8be87ddc4ff2bc461c2ecc606ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e58c24d8ffbf7f55eb0346154cb5d45"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::_staticfunc</b> )(A0, A1, A2, A3)</td></tr>
<tr class="separator:ga5e58c24d8ffbf7f55eb0346154cb5d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cd286f4e7d5547a8b161a9432a9978"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::_boundfunc</b> )(_class *, A0, A1, A2, A3)</td></tr>
<tr class="separator:gab7cd286f4e7d5547a8b161a9432a9978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e9d752c5187e18ea2cfa211ef3a1c9"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::_methodfunc</b> )(A0, A1, A2, A3)</td></tr>
<tr class="separator:gac2e9d752c5187e18ea2cfa211ef3a1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da1f5c15f3d47cfeb049c9af5ba73e2"><td class="memItemLeft" align="right" valign="top"><a id="ga6da1f5c15f3d47cfeb049c9af5ba73e2" name="ga6da1f5c15f3d47cfeb049c9af5ba73e2"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::ops::call</b> )(const void *, A0, A1, A2, A3)</td></tr>
<tr class="separator:ga6da1f5c15f3d47cfeb049c9af5ba73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad12d77acd180a72a41a3a17b576015"><td class="memItemLeft" align="right" valign="top"><a id="gaaad12d77acd180a72a41a3a17b576015" name="gaaad12d77acd180a72a41a3a17b576015"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:gaaad12d77acd180a72a41a3a17b576015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05db6ff73bef7ecccf49fab1baa55d20"><td class="memItemLeft" align="right" valign="top"><a id="ga05db6ff73bef7ecccf49fab1baa55d20" name="ga05db6ff73bef7ecccf49fab1baa55d20"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:ga05db6ff73bef7ecccf49fab1baa55d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c26e738b7971d10468c2a9b198a15e"><td class="memItemLeft" align="right" valign="top"><a id="ga79c26e738b7971d10468c2a9b198a15e" name="ga79c26e738b7971d10468c2a9b198a15e"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:ga79c26e738b7971d10468c2a9b198a15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf680ce6471b2d9a3e70cc9a10fe9e14"><td class="memItemLeft" align="right" valign="top"><a id="gacf680ce6471b2d9a3e70cc9a10fe9e14" name="gacf680ce6471b2d9a3e70cc9a10fe9e14"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:gacf680ce6471b2d9a3e70cc9a10fe9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf620b1df9cf38345aede81af3b8899ba"><td class="memItemLeft" align="right" valign="top"><a id="gaf620b1df9cf38345aede81af3b8899ba" name="gaf620b1df9cf38345aede81af3b8899ba"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:gaf620b1df9cf38345aede81af3b8899ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bb4d7fad428747f5b538ef6e60c23f"><td class="memItemLeft" align="right" valign="top"><a id="ga63bb4d7fad428747f5b538ef6e60c23f" name="ga63bb4d7fad428747f5b538ef6e60c23f"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga63bb4d7fad428747f5b538ef6e60c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573c16d6b5ada252f9f5b2f12518c740"><td class="memItemLeft" align="right" valign="top"><a id="ga573c16d6b5ada252f9f5b2f12518c740" name="ga573c16d6b5ada252f9f5b2f12518c740"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::func</b> )(T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga573c16d6b5ada252f9f5b2f12518c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e01ff8c3bae3f7334fe63fca7f5c07d"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::_staticfunc</b> )(A0, A1, A2, A3, A4)</td></tr>
<tr class="separator:ga0e01ff8c3bae3f7334fe63fca7f5c07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2acf70a5f12685a23e1a41888e4044"><td class="memItemLeft" >
void(*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::_boundfunc</b> )(_class *, A0, A1, A2, A3, A4)</td></tr>
<tr class="separator:gaec2acf70a5f12685a23e1a41888e4044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac43248d898a11a15a963f9fe143b79f5"><td class="memItemLeft" >
void(_class::*&#160;&#160;&#160;<b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::_methodfunc</b> )(A0, A1, A2, A3, A4)</td></tr>
<tr class="separator:gac43248d898a11a15a963f9fe143b79f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6db0e9d15296fa418528a9ce445130"><td class="memItemLeft" align="right" valign="top"><a id="ga4a6db0e9d15296fa418528a9ce445130" name="ga4a6db0e9d15296fa418528a9ce445130"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::ops::call</b> )(const void *, A0, A1, A2, A3, A4)</td></tr>
<tr class="separator:ga4a6db0e9d15296fa418528a9ce445130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfbc352cdd5bfd87a927100ff5de800"><td class="memItemLeft" align="right" valign="top"><a id="gaacfbc352cdd5bfd87a927100ff5de800" name="gaacfbc352cdd5bfd87a927100ff5de800"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::ops::move</b> )(void *, const void *)</td></tr>
<tr class="separator:gaacfbc352cdd5bfd87a927100ff5de800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc8e3a1017b01035697daf58af8121b"><td class="memItemLeft" align="right" valign="top"><a id="ga4cc8e3a1017b01035697daf58af8121b" name="ga4cc8e3a1017b01035697daf58af8121b"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::ops::dtor</b> )(void *)</td></tr>
<tr class="separator:ga4cc8e3a1017b01035697daf58af8121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d760378f51729d326df3aa77e0e3db"><td class="memItemLeft" align="right" valign="top"><a id="ga49d760378f51729d326df3aa77e0e3db" name="ga49d760378f51729d326df3aa77e0e3db"></a>
M&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::method_context&lt; O, M &gt;::method</b></td></tr>
<tr class="separator:ga49d760378f51729d326df3aa77e0e3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc1c6da764db7ca0caff904f48813414"><td class="memItemLeft" align="right" valign="top"><a id="gadc1c6da764db7ca0caff904f48813414" name="gadc1c6da764db7ca0caff904f48813414"></a>
O *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::method_context&lt; O, M &gt;::obj</b></td></tr>
<tr class="separator:gadc1c6da764db7ca0caff904f48813414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a2e5b39b3e6e73e123e0ac18f653fb"><td class="memItemLeft" align="right" valign="top"><a id="ga08a2e5b39b3e6e73e123e0ac18f653fb" name="ga08a2e5b39b3e6e73e123e0ac18f653fb"></a>
F&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::function_context&lt; F, A &gt;::func</b></td></tr>
<tr class="separator:ga08a2e5b39b3e6e73e123e0ac18f653fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87461400f41288bba9c7a04009a498dd"><td class="memItemLeft" align="right" valign="top"><a id="ga87461400f41288bba9c7a04009a498dd" name="ga87461400f41288bba9c7a04009a498dd"></a>
A *&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::function_context&lt; F, A &gt;::arg</b></td></tr>
<tr class="separator:ga87461400f41288bba9c7a04009a498dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689911b75562b995e216d5c4db982b64"><td class="memItemLeft" align="right" valign="top"><a id="ga689911b75562b995e216d5c4db982b64" name="ga689911b75562b995e216d5c4db982b64"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::func</b> )(T *))</td></tr>
<tr class="separator:ga689911b75562b995e216d5c4db982b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memItemLeft" align="right" valign="top"><a id="ga1039d88edb3bf471ffd231b2b9e674a5" name="ga1039d88edb3bf471ffd231b2b9e674a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A1</b></td></tr>
<tr class="separator:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memItemLeft" align="right" valign="top"><a id="gaff8fcdfa5c88334f1e8b265c3bc39c71" name="gaff8fcdfa5c88334f1e8b265c3bc39c71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A2</b></td></tr>
<tr class="separator:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memItemLeft" align="right" valign="top"><a id="gaeae6936924cb2d9e94265195d8fdb8c8" name="gaeae6936924cb2d9e94265195d8fdb8c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A3</b></td></tr>
<tr class="separator:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136c3a148862b61d173c9425159672f5"><td class="memItemLeft" align="right" valign="top">M&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga136c3a148862b61d173c9425159672f5">mbed::CallChain::method</a></td></tr>
<tr class="separator:ga136c3a148862b61d173c9425159672f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407d1bfd8d91005fe799dd5dc69a5f43"><td class="memItemLeft" align="right" valign="top"><a id="ga407d1bfd8d91005fe799dd5dc69a5f43" name="ga407d1bfd8d91005fe799dd5dc69a5f43"></a>
R(T::*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::member</b> )(A1))</td></tr>
<tr class="separator:ga407d1bfd8d91005fe799dd5dc69a5f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab845c1fefac6f35abee661605cd07c09"><td class="memItemLeft" align="right" valign="top"><a id="gab845c1fefac6f35abee661605cd07c09" name="gab845c1fefac6f35abee661605cd07c09"></a>
R(*)(A1)&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, A1 &gt;::get_function</b> ()</td></tr>
<tr class="separator:gab845c1fefac6f35abee661605cd07c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d43bad261f729d29db6398d24bb222b"><td class="memItemLeft" align="right" valign="top"><a id="ga0d43bad261f729d29db6398d24bb222b" name="ga0d43bad261f729d29db6398d24bb222b"></a>
R(T::*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::member</b> )())</td></tr>
<tr class="separator:ga0d43bad261f729d29db6398d24bb222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga792794bb5157153b294de75f0fc6fc92"><td class="memItemLeft" align="right" valign="top"><a id="ga792794bb5157153b294de75f0fc6fc92" name="ga792794bb5157153b294de75f0fc6fc92"></a>
R(*)()&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::FunctionPointerArg1&lt; R, void &gt;::get_function</b> ()</td></tr>
<tr class="separator:ga792794bb5157153b294de75f0fc6fc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacf8c4e26c5bee9e3f45abdb065a46c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gabacf8c4e26c5bee9e3f45abdb065a46c">mbed::transaction_t::tx_buffer</a></td></tr>
<tr class="separator:gabacf8c4e26c5bee9e3f45abdb065a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2251489b9b40afc9b6ee367d0c7746d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gaa2251489b9b40afc9b6ee367d0c7746d">mbed::transaction_t::tx_length</a></td></tr>
<tr class="separator:gaa2251489b9b40afc9b6ee367d0c7746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56698177b98a193cdea584d5d9e83a51"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga56698177b98a193cdea584d5d9e83a51">mbed::transaction_t::rx_buffer</a></td></tr>
<tr class="separator:ga56698177b98a193cdea584d5d9e83a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefd7a94e22cadc29445edc25d33ff68"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gafefd7a94e22cadc29445edc25d33ff68">mbed::transaction_t::rx_length</a></td></tr>
<tr class="separator:gafefd7a94e22cadc29445edc25d33ff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab833266b58930c495adc9ca6ca6ac6ee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gab833266b58930c495adc9ca6ca6ac6ee">mbed::transaction_t::event</a></td></tr>
<tr class="separator:gab833266b58930c495adc9ca6ca6ac6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac002693cf63d9a1a05789c966de5053d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">event_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gac002693cf63d9a1a05789c966de5053d">mbed::transaction_t::callback</a></td></tr>
<tr class="separator:gac002693cf63d9a1a05789c966de5053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ac843f6ce2f59a3d65d7d8beac1f11"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga07ac843f6ce2f59a3d65d7d8beac1f11">mbed::transaction_t::width</a></td></tr>
<tr class="separator:ga07ac843f6ce2f59a3d65d7d8beac1f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friend-members" name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R()&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R()&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R(A0)&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R(A0)&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R(A0, A1)&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R(A0, A1)&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R(A0, A1, A2)&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R(A0, A1, A2)&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9ed4d58bf74294768014653722a608"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#gadc9ed4d58bf74294768014653722a608">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::operator==</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:gadc9ed4d58bf74294768014653722a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a2cb57f30416b3d811249789a50243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform.html#ga19a2cb57f30416b3d811249789a50243">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;::operator!=</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;l, const <a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp;r)</td></tr>
<tr class="separator:ga19a2cb57f30416b3d811249789a50243"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2d03065d5f5d1d2096f06f31218509fb" name="ga2d03065d5f5d1d2096f06f31218509fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d03065d5f5d1d2096f06f31218509fb">&#9670;&nbsp;</a></span>MBED_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td>&#160;&#160;&#160;__attribute__((aligned(N)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="group__platform.html#ga2d03065d5f5d1d2096f06f31218509fb">MBED_ALIGN(N)</a> Declare a variable to be aligned on an N-byte boundary.</p>
<dl class="section note"><dt>Note</dt><dd>IAR does not support alignment greater than word size on the stack</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga2d03065d5f5d1d2096f06f31218509fb">MBED_ALIGN</a>(16) char a;</div>
<div class="ttc" id="agroup__platform_html_ga2d03065d5f5d1d2096f06f31218509fb"><div class="ttname"><a href="group__platform.html#ga2d03065d5f5d1d2096f06f31218509fb">MBED_ALIGN</a></div><div class="ttdeci">#define MBED_ALIGN(N)</div><div class="ttdef"><b>Definition:</b> toolchain.h:72</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2fb68573313abfce1681c990c68fb089" name="ga2fb68573313abfce1681c990c68fb089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb68573313abfce1681c990c68fb089">&#9670;&nbsp;</a></span>MBED_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                     \</div>
<div class="line">    if (!(expr)) {                                       \</div>
<div class="line">        mbed_assert_internal(#expr, __FILE__, __LINE__); \</div>
<div class="line">    }                                                    \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0dee71e8eee185cce404cecdd7e51656" name="ga0dee71e8eee185cce404cecdd7e51656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dee71e8eee185cce404cecdd7e51656">&#9670;&nbsp;</a></span>MBED_CALLER_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_CALLER_ADDR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="group__platform.html#ga0dee71e8eee185cce404cecdd7e51656">MBED_CALLER_ADDR()</a> Returns the caller of the current function.</p>
<dl class="section note"><dt>Note</dt><dd>This macro is only implemented for GCC and ARMCC.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;This function was called from %p&quot;</span>, <a class="code hl_define" href="group__platform.html#ga0dee71e8eee185cce404cecdd7e51656">MBED_CALLER_ADDR</a>());</div>
<div class="ttc" id="agroup__platform_html_ga0dee71e8eee185cce404cecdd7e51656"><div class="ttname"><a href="group__platform.html#ga0dee71e8eee185cce404cecdd7e51656">MBED_CALLER_ADDR</a></div><div class="ttdeci">#define MBED_CALLER_ADDR()</div><div class="ttdef"><b>Definition:</b> toolchain.h:267</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Address of the calling function </dd></dl>

</div>
</div>
<a id="ga6944490e766215f9932c933a35219422" name="ga6944490e766215f9932c933a35219422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6944490e766215f9932c933a35219422">&#9670;&nbsp;</a></span>MBED_CONCAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_CONCAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;MBED_CONCAT_(a, b)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_CONCAT Concatenate tokens together</p>
<dl class="section note"><dt>Note</dt><dd>Expands tokens before concatenation</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Creates a unique label based on the line number</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_define" href="group__platform.html#ga6944490e766215f9932c933a35219422">MBED_CONCAT</a>(UNIQUE_LABEL_, __LINE__) = 1;</div>
<div class="ttc" id="agroup__platform_html_ga6944490e766215f9932c933a35219422"><div class="ttname"><a href="group__platform.html#ga6944490e766215f9932c933a35219422">MBED_CONCAT</a></div><div class="ttdeci">#define MBED_CONCAT(a, b)</div><div class="ttdef"><b>Definition:</b> mbed_preprocessor.h:33</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3a7865da3333447747552904fc672ea0" name="ga3a7865da3333447747552904fc672ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a7865da3333447747552904fc672ea0">&#9670;&nbsp;</a></span>MBED_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_DEPRECATED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_DEPRECATED("message string") Mark a function declaration as deprecated, if it used then a warning will be issued by the compiler possibly including the provided message. Note that not all compilers are able to display the message.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga3a7865da3333447747552904fc672ea0">MBED_DEPRECATED</a>(<span class="stringliteral">&quot;don&#39;t foo any more, bar instead&quot;</span>)</div>
<div class="line">void foo(<span class="keywordtype">int</span> arg);</div>
<div class="ttc" id="agroup__platform_html_ga3a7865da3333447747552904fc672ea0"><div class="ttname"><a href="group__platform.html#ga3a7865da3333447747552904fc672ea0">MBED_DEPRECATED</a></div><div class="ttdeci">#define MBED_DEPRECATED(M)</div><div class="ttdef"><b>Definition:</b> toolchain.h:228</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2822a5c443e30d9fff9c591743ac616d" name="ga2822a5c443e30d9fff9c591743ac616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2822a5c443e30d9fff9c591743ac616d">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_DEPRECATED_SINCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">D, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__platform.html#ga3a7865da3333447747552904fc672ea0">MBED_DEPRECATED</a>(M &quot; [since &quot; D &quot;]&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_DEPRECATED_SINCE("version", "message string") Mark a function declaration as deprecated, noting that the declaration was deprecated on the specified version. If the function is used then a warning will be issued by the compiler possibly including the provided message. Note that not all compilers are able to display this message.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga2822a5c443e30d9fff9c591743ac616d">MBED_DEPRECATED_SINCE</a>(<span class="stringliteral">&quot;mbed-os-5.1&quot;</span>, <span class="stringliteral">&quot;don&#39;t foo any more, bar instead&quot;</span>)</div>
<div class="line">void foo(<span class="keywordtype">int</span> arg);</div>
<div class="ttc" id="agroup__platform_html_ga2822a5c443e30d9fff9c591743ac616d"><div class="ttname"><a href="group__platform.html#ga2822a5c443e30d9fff9c591743ac616d">MBED_DEPRECATED_SINCE</a></div><div class="ttdeci">#define MBED_DEPRECATED_SINCE(D, M)</div><div class="ttdef"><b>Definition:</b> toolchain.h:245</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga4f9a9e7b05304896ba993457907b3f28" name="ga4f9a9e7b05304896ba993457907b3f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9a9e7b05304896ba993457907b3f28">&#9670;&nbsp;</a></span>MBED_FORCEINLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_FORCEINLINE&#160;&#160;&#160;static inline</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_FORCEINLINE Declare a function that must always be inlined. Failure to inline such a function will result in an error.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> <span class="keywordtype">void</span> foo() {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_ga4f9a9e7b05304896ba993457907b3f28"><div class="ttname"><a href="group__platform.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a></div><div class="ttdeci">#define MBED_FORCEINLINE</div><div class="ttdef"><b>Definition:</b> toolchain.h:158</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gab7676a6962d493ab9e0c692e942d618a" name="gab7676a6962d493ab9e0c692e942d618a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7676a6962d493ab9e0c692e942d618a">&#9670;&nbsp;</a></span>MBED_NORETURN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_NORETURN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_NORETURN Declare a function that will never return.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#gab7676a6962d493ab9e0c692e942d618a">MBED_NORETURN</a> <span class="keywordtype">void</span> foo() {</div>
<div class="line">    <span class="comment">// must never return</span></div>
<div class="line">    <span class="keywordflow">while</span> (1) {}</div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_gab7676a6962d493ab9e0c692e942d618a"><div class="ttname"><a href="group__platform.html#gab7676a6962d493ab9e0c692e942d618a">MBED_NORETURN</a></div><div class="ttdeci">#define MBED_NORETURN</div><div class="ttdef"><b>Definition:</b> toolchain.h:180</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9f95037893bd45bde2587185095f4e3b" name="ga9f95037893bd45bde2587185095f4e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f95037893bd45bde2587185095f4e3b">&#9670;&nbsp;</a></span>MBED_PACKED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_PACKED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct</td><td>)</td>
          <td>&#160;&#160;&#160;struct __attribute__((packed))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_PACKED Pack a structure, preventing any padding from being added between fields.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga9f95037893bd45bde2587185095f4e3b">MBED_PACKED</a>(<span class="keyword">struct</span>) foo {</div>
<div class="line">    <span class="keywordtype">char</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line">};</div>
<div class="ttc" id="agroup__platform_html_ga9f95037893bd45bde2587185095f4e3b"><div class="ttname"><a href="group__platform.html#ga9f95037893bd45bde2587185095f4e3b">MBED_PACKED</a></div><div class="ttdeci">#define MBED_PACKED(struct)</div><div class="ttdef"><b>Definition:</b> toolchain.h:52</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga28e5edc9118df93fb8d8aa85af2baa7a" name="ga28e5edc9118df93fb8d8aa85af2baa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e5edc9118df93fb8d8aa85af2baa7a">&#9670;&nbsp;</a></span>MBED_PURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_PURE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_PURE Hint to the compiler that a function depends only on parameters</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#ga28e5edc9118df93fb8d8aa85af2baa7a">MBED_PURE</a> <span class="keywordtype">int</span> foo(<span class="keywordtype">int</span> arg){</div>
<div class="line">    <span class="comment">// no access to global variables</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_ga28e5edc9118df93fb8d8aa85af2baa7a"><div class="ttname"><a href="group__platform.html#ga28e5edc9118df93fb8d8aa85af2baa7a">MBED_PURE</a></div><div class="ttdeci">#define MBED_PURE</div><div class="ttdef"><b>Definition:</b> toolchain.h:136</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gadab8ec75d3f2ad841b5ede19656902c5" name="gadab8ec75d3f2ad841b5ede19656902c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab8ec75d3f2ad841b5ede19656902c5">&#9670;&nbsp;</a></span>MBED_STATIC_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_STATIC_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    enum {<a class="el" href="group__platform.html#ga6944490e766215f9932c933a35219422">MBED_CONCAT</a>(MBED_ASSERTION_AT_, __LINE__) = sizeof(char[(expr) ? 1 : -1])}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_STATIC_ASSERT Declare compile-time assertions, results in compile-time error if condition is false</p>
<p >The assertion acts as a declaration that can be placed at file scope, in a code block (except after a label), or as a member of a C++ class/struct/union.</p>
<dl class="section note"><dt>Note</dt><dd>Use of MBED_STATIC_ASSERT as a member of a struct/union is limited:<ul>
<li>In C++, MBED_STATIC_ASSERT is valid in class/struct/union scope.</li>
<li>In C, MBED_STATIC_ASSERT is not valid in struct/union scope, and MBED_STRUCT_STATIC_ASSERT is provided as an alternative that is valid in C and C++ class/struct/union scope.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__platform.html#gadab8ec75d3f2ad841b5ede19656902c5">MBED_STATIC_ASSERT</a>(MBED_LIBRARY_VERSION &gt;= 120,</div>
<div class="line">        <span class="stringliteral">&quot;The mbed library must be at least version 120&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <a class="code hl_define" href="group__platform.html#gadab8ec75d3f2ad841b5ede19656902c5">MBED_STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) &gt;= <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>),</div>
<div class="line">            <span class="stringliteral">&quot;An int must be larger than a char&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_gadab8ec75d3f2ad841b5ede19656902c5"><div class="ttname"><a href="group__platform.html#gadab8ec75d3f2ad841b5ede19656902c5">MBED_STATIC_ASSERT</a></div><div class="ttdeci">#define MBED_STATIC_ASSERT(expr, msg)</div><div class="ttdef"><b>Definition:</b> mbed_assert.h:91</div></div>
<div class="ttc" id="amain_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> main.cpp:62</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga888934524aa721fb113a92f81310e8aa" name="ga888934524aa721fb113a92f81310e8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga888934524aa721fb113a92f81310e8aa">&#9670;&nbsp;</a></span>MBED_STRINGIFY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_STRINGIFY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;MBED_STRINGIFY_(a)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_STRINGIFY Converts tokens into strings</p>
<dl class="section note"><dt>Note</dt><dd>Expands tokens before stringification</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Creates a string based on the parameters</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *c = <a class="code hl_define" href="group__platform.html#ga888934524aa721fb113a92f81310e8aa">MBED_STRINGIFY</a>(This is a ridiculous way to create a <span class="keywordtype">string</span>)</div>
<div class="ttc" id="agroup__platform_html_ga888934524aa721fb113a92f81310e8aa"><div class="ttname"><a href="group__platform.html#ga888934524aa721fb113a92f81310e8aa">MBED_STRINGIFY</a></div><div class="ttdeci">#define MBED_STRINGIFY(a)</div><div class="ttdef"><b>Definition:</b> mbed_preprocessor.h:47</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gadc404d96975271a839d5f130461e4c77" name="gadc404d96975271a839d5f130461e4c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc404d96975271a839d5f130461e4c77">&#9670;&nbsp;</a></span>MBED_STRUCT_STATIC_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_STRUCT_STATIC_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;int : (expr) ? 0 : -1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_STRUCT_STATIC_ASSERT Declare compile-time assertions, results in compile-time error if condition is false</p>
<p >Unlike MBED_STATIC_ASSERT, MBED_STRUCT_STATIC_ASSERT can and must be used as a member of a C/C++ class/struct/union.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>thing {</div>
<div class="line">    <a class="code hl_define" href="group__platform.html#gadab8ec75d3f2ad841b5ede19656902c5">MBED_STATIC_ASSERT</a>(2 + 2 == 4,</div>
<div class="line">            <span class="stringliteral">&quot;Hopefully the universe is mathematically consistent&quot;</span>);</div>
<div class="line">};</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga612b8ce3a819349edecfc605056297fc" name="ga612b8ce3a819349edecfc605056297fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612b8ce3a819349edecfc605056297fc">&#9670;&nbsp;</a></span>MBED_UNREACHABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_UNREACHABLE&#160;&#160;&#160;while (1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_UNREACHABLE An unreachable statement. If the statement is reached, behaviour is undefined. Useful in situations where the compiler cannot deduce the unreachability of code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> arg) {</div>
<div class="line">    <span class="keywordflow">switch</span> (arg) {</div>
<div class="line">        <span class="keywordflow">case</span> 1: <span class="keywordflow">return</span> 1;</div>
<div class="line">        <span class="keywordflow">case</span> 2: <span class="keywordflow">return</span> 2;</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="group__platform.html#ga612b8ce3a819349edecfc605056297fc">MBED_UNREACHABLE</a>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_ga612b8ce3a819349edecfc605056297fc"><div class="ttname"><a href="group__platform.html#ga612b8ce3a819349edecfc605056297fc">MBED_UNREACHABLE</a></div><div class="ttdeci">#define MBED_UNREACHABLE</div><div class="ttdef"><b>Definition:</b> toolchain.h:206</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3e0b3dc191a8e64de80be44bbc8d5193" name="ga3e0b3dc191a8e64de80be44bbc8d5193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0b3dc191a8e64de80be44bbc8d5193">&#9670;&nbsp;</a></span>MBED_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_UNUSED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_UNUSED Declare a function argument to be unused, suppressing compiler warnings</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_define" href="group__platform.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <span class="keywordtype">int</span> arg) {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_ga3e0b3dc191a8e64de80be44bbc8d5193"><div class="ttname"><a href="group__platform.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a></div><div class="ttdeci">#define MBED_UNUSED</div><div class="ttdef"><b>Definition:</b> toolchain.h:91</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa7bb5d6a31c6888e54eea75c60f06400" name="gaa7bb5d6a31c6888e54eea75c60f06400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7bb5d6a31c6888e54eea75c60f06400">&#9670;&nbsp;</a></span>MBED_WEAK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_WEAK&#160;&#160;&#160;__attribute__((weak))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MBED_WEAK Mark a function as being weak.</p>
<dl class="section note"><dt>Note</dt><dd>weak functions are not friendly to making code re-usable, as they can only be overridden once (and if they are multiply overridden the linker will emit no warning). You should not normally use weak symbols as part of the API to re-usable modules.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;toolchain.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__platform.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a> <span class="keywordtype">void</span> foo() {</div>
<div class="line">    <span class="comment">// a weak implementation of foo that can be overriden by a definition</span></div>
<div class="line">    <span class="comment">// without  __weak</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_gaa7bb5d6a31c6888e54eea75c60f06400"><div class="ttname"><a href="group__platform.html#gaa7bb5d6a31c6888e54eea75c60f06400">MBED_WEAK</a></div><div class="ttdeci">#define MBED_WEAK</div><div class="ttdef"><b>Definition:</b> toolchain.h:117</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga41b05bedaf7cb911c344087b8449642e" name="ga41b05bedaf7cb911c344087b8449642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41b05bedaf7cb911c344087b8449642e">&#9670;&nbsp;</a></span>mbed_mem_trace_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mbed_mem_trace_cb_t) (uint8_t op, void *res, void *caller,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Type of the callback used by the memory tracer. This callback is called when a memory allocation operation (malloc, realloc, calloc, free) is called and tracing is enabled for that memory allocation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>the ID of the operation (MBED_MEM_TRACE_MALLOC, MBED_MEM_TRACE_REALLOC, MBED_MEM_TRACE_CALLOC or MBED_MEM_TRACE_FREE). </td></tr>
    <tr><td class="paramname">res</td><td>the result that the memory operation returned (NULL for 'free'). </td></tr>
    <tr><td class="paramname">caller</td><td>the caller of the memory operation. Note that the value of 'caller' might be unreliable.</td></tr>
  </table>
  </dd>
</dl>
<p>The rest of the parameters passed 'mbed_mem_trace_cb_t' are the same as the memory operations that triggered its call (see 'man malloc' for details):</p>
<ul>
<li>for malloc: cb(MBED_MEM_TRACE_MALLOC, res, caller, size).</li>
<li>for realloc: cb(MBED_MEM_TRACE_REALLOC, res, caller, ptr, size).</li>
<li>for calloc: cb(MBED_MEM_TRACE_CALLOC, res, caller, nmemb, size).</li>
<li>for free: cb(MBED_MEM_TRACE_FREE, NULL, caller, ptr). </li>
</ul>

</div>
</div>
<a id="ga0deb66451ed70cb0c99bf0255e1562d1" name="ga0deb66451ed70cb0c99bf0255e1562d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0deb66451ed70cb0c99bf0255e1562d1">&#9670;&nbsp;</a></span>pFunctionPointer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;void()&gt;* <a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">mbed::pFunctionPointer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Group one or more functions in an instance of a <a class="el" href="classmbed_1_1_call_chain.html">CallChain</a>, then call them in sequence using <a class="el" href="group__platform.html#gac911bd44ea0a14da0b0dd46187bf1081">CallChain::call()</a>. Used mostly by the interrupt chaining code, but can be used for other purposes.</p>
<p >@Note Synchronization level: Not protected</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_call_chain.html">CallChain</a> chain;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> first(<span class="keywordtype">void</span>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;&#39;first&#39; function.\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> second(<span class="keywordtype">void</span>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;&#39;second&#39; function.\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Test {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> f(<span class="keywordtype">void</span>) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;A::f (class member).\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    Test test;</div>
<div class="line"> </div>
<div class="line">    chain.<a class="code hl_function" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(second);</div>
<div class="line">    chain.<a class="code hl_function" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a>(first);</div>
<div class="line">    chain.<a class="code hl_function" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(&amp;test, &amp;Test::f);</div>
<div class="line">    chain.<a class="code hl_function" href="group__platform.html#gac911bd44ea0a14da0b0dd46187bf1081">call</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassmbed_1_1_call_chain_html"><div class="ttname"><a href="classmbed_1_1_call_chain.html">mbed::CallChain</a></div><div class="ttdef"><b>Definition:</b> CallChain.h:68</div></div>
<div class="ttc" id="agroup__platform_html_ga19929d1fbe56245a5cf4af62696ec1a6"><div class="ttname"><a href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">mbed::CallChain::add</a></div><div class="ttdeci">pFunctionPointer_t add(Callback&lt; void()&gt; func)</div></div>
<div class="ttc" id="agroup__platform_html_ga8784da11faa09b23c7e290ce3326d10a"><div class="ttname"><a href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">mbed::CallChain::add_front</a></div><div class="ttdeci">pFunctionPointer_t add_front(Callback&lt; void()&gt; func)</div></div>
<div class="ttc" id="agroup__platform_html_gac911bd44ea0a14da0b0dd46187bf1081"><div class="ttname"><a href="group__platform.html#gac911bd44ea0a14da0b0dd46187bf1081">mbed::CallChain::call</a></div><div class="ttdeci">void call()</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19929d1fbe56245a5cf4af62696ec1a6" name="ga19929d1fbe56245a5cf4af62696ec1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19929d1fbe56245a5cf4af62696ec1a6">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a> mbed::CallChain::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a function at the end of the chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A pointer to a void function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function object created for 'func' </dd></dl>

</div>
</div>
<a id="ga8784da11faa09b23c7e290ce3326d10a" name="ga8784da11faa09b23c7e290ce3326d10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8784da11faa09b23c7e290ce3326d10a">&#9670;&nbsp;</a></span>add_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a> mbed::CallChain::add_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a function at the beginning of the chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A pointer to a void function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function object created for 'func' </dd></dl>

</div>
</div>
<a id="ga63447ae6eb119c2a776cf4372a1e07f2" name="ga63447ae6eb119c2a776cf4372a1e07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63447ae6eb119c2a776cf4372a1e07f2">&#9670;&nbsp;</a></span>attach() <span class="overload">[1/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5463b7573a9e3105cfb8abef698aeab7" name="ga5463b7573a9e3105cfb8abef698aeab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5463b7573a9e3105cfb8abef698aeab7">&#9670;&nbsp;</a></span>attach() <span class="overload">[2/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4db638e222c05bd69b531d81023fed43" name="ga4db638e222c05bd69b531d81023fed43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db638e222c05bd69b531d81023fed43">&#9670;&nbsp;</a></span>attach() <span class="overload">[3/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b0b585fc134202df5f42d100f6a0a1a" name="ga3b0b585fc134202df5f42d100f6a0a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0b585fc134202df5f42d100f6a0a1a">&#9670;&nbsp;</a></span>attach() <span class="overload">[4/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga531eafe0e6fa40139a01481e7e290877" name="ga531eafe0e6fa40139a01481e7e290877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531eafe0e6fa40139a01481e7e290877">&#9670;&nbsp;</a></span>attach() <span class="overload">[5/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8b8615214b0e06d1f4806434e689a5e" name="gad8b8615214b0e06d1f4806434e689a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8b8615214b0e06d1f4806434e689a5e">&#9670;&nbsp;</a></span>attach() <span class="overload">[6/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb2b742a3bdbba4fba504a3fd6accbbc" name="gafb2b742a3bdbba4fba504a3fd6accbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2b742a3bdbba4fba504a3fd6accbbc">&#9670;&nbsp;</a></span>attach() <span class="overload">[7/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga709b7b6e91b664960f9ae62c8c7e11bd" name="ga709b7b6e91b664960f9ae62c8c7e11bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709b7b6e91b664960f9ae62c8c7e11bd">&#9670;&nbsp;</a></span>attach() <span class="overload">[8/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c063a4b158272095eb5743aa098c602" name="ga7c063a4b158272095eb5743aa098c602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c063a4b158272095eb5743aa098c602">&#9670;&nbsp;</a></span>attach() <span class="overload">[9/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6329fa274e1d2dda2ed5dfda29ac98b" name="gac6329fa274e1d2dda2ed5dfda29ac98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6329fa274e1d2dda2ed5dfda29ac98b">&#9670;&nbsp;</a></span>attach() <span class="overload">[10/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7354e51ff36445585f6bf48aec2a28f6" name="ga7354e51ff36445585f6bf48aec2a28f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7354e51ff36445585f6bf48aec2a28f6">&#9670;&nbsp;</a></span>attach() <span class="overload">[11/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f19afc976cbefdfa087449670fdecd2" name="ga8f19afc976cbefdfa087449670fdecd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f19afc976cbefdfa087449670fdecd2">&#9670;&nbsp;</a></span>attach() <span class="overload">[12/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga287a2cabe3e1fd3ed55e2560801e933b" name="ga287a2cabe3e1fd3ed55e2560801e933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287a2cabe3e1fd3ed55e2560801e933b">&#9670;&nbsp;</a></span>attach() <span class="overload">[13/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e01eb4369945b540693db494ec9d687" name="ga7e01eb4369945b540693db494ec9d687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e01eb4369945b540693db494ec9d687">&#9670;&nbsp;</a></span>attach() <span class="overload">[14/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1bedad813fa000601c77cf9dd457405" name="gaa1bedad813fa000601c77cf9dd457405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1bedad813fa000601c77cf9dd457405">&#9670;&nbsp;</a></span>attach() <span class="overload">[15/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc502f86dd2b43c2478bd7ebdf835857" name="gabc502f86dd2b43c2478bd7ebdf835857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc502f86dd2b43c2478bd7ebdf835857">&#9670;&nbsp;</a></span>attach() <span class="overload">[16/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab66e9bf78026c1ba877b0c44f53e9a4c" name="gab66e9bf78026c1ba877b0c44f53e9a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66e9bf78026c1ba877b0c44f53e9a4c">&#9670;&nbsp;</a></span>attach() <span class="overload">[17/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7091296f312f20c7f22a7af6d8d989b6" name="ga7091296f312f20c7f22a7af6d8d989b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7091296f312f20c7f22a7af6d8d989b6">&#9670;&nbsp;</a></span>attach() <span class="overload">[18/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39d49c398ad2e8e3a2d2dad77d2f20e0" name="ga39d49c398ad2e8e3a2d2dad77d2f20e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d49c398ad2e8e3a2d2dad77d2f20e0">&#9670;&nbsp;</a></span>attach() <span class="overload">[19/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga9db277328da843d4499e22544ab33804" name="ga9db277328da843d4499e22544ab33804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db277328da843d4499e22544ab33804">&#9670;&nbsp;</a></span>attach() <span class="overload">[20/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga721437bebbd674f31810becdec566725" name="ga721437bebbd674f31810becdec566725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga721437bebbd674f31810becdec566725">&#9670;&nbsp;</a></span>attach() <span class="overload">[21/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="gad3b60eca4b40e0852d737c190e5ac136" name="gad3b60eca4b40e0852d737c190e5ac136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3b60eca4b40e0852d737c190e5ac136">&#9670;&nbsp;</a></span>attach() <span class="overload">[22/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga58cac9fb8c162c652eaa65061cda8487" name="ga58cac9fb8c162c652eaa65061cda8487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58cac9fb8c162c652eaa65061cda8487">&#9670;&nbsp;</a></span>attach() <span class="overload">[23/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="gab9b5eec69b52d7bd62e9f2b7b2a96dfd" name="gab9b5eec69b52d7bd62e9f2b7b2a96dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b5eec69b52d7bd62e9f2b7b2a96dfd">&#9670;&nbsp;</a></span>attach() <span class="overload">[24/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga4e8526e1baef1ea1a7225ce7b22aad70" name="ga4e8526e1baef1ea1a7225ce7b22aad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8526e1baef1ea1a7225ce7b22aad70">&#9670;&nbsp;</a></span>attach() <span class="overload">[25/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb5c0e18f6f21537ab1b5e39c5c66ed2" name="gabb5c0e18f6f21537ab1b5e39c5c66ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb5c0e18f6f21537ab1b5e39c5c66ed2">&#9670;&nbsp;</a></span>attach() <span class="overload">[26/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e92272a770036c4e598a19418ae1ed5" name="ga9e92272a770036c4e598a19418ae1ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e92272a770036c4e598a19418ae1ed5">&#9670;&nbsp;</a></span>attach() <span class="overload">[27/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04ca78ed9faf734c6f6e78d2f5d85dd6" name="ga04ca78ed9faf734c6f6e78d2f5d85dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ca78ed9faf734c6f6e78d2f5d85dd6">&#9670;&nbsp;</a></span>attach() <span class="overload">[28/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga313f9560bc2f37a8e26f3d34e281d567" name="ga313f9560bc2f37a8e26f3d34e281d567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga313f9560bc2f37a8e26f3d34e281d567">&#9670;&nbsp;</a></span>attach() <span class="overload">[29/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga905e914bb0d8f98948c3cc670f288536" name="ga905e914bb0d8f98948c3cc670f288536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905e914bb0d8f98948c3cc670f288536">&#9670;&nbsp;</a></span>attach() <span class="overload">[30/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a7bb2ff0ffda28d39264ca2e513a99b" name="ga3a7bb2ff0ffda28d39264ca2e513a99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a7bb2ff0ffda28d39264ca2e513a99b">&#9670;&nbsp;</a></span>attach() <span class="overload">[31/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46ccacf0705e725985397bbb30e36e5b" name="ga46ccacf0705e725985397bbb30e36e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ccacf0705e725985397bbb30e36e5b">&#9670;&nbsp;</a></span>attach() <span class="overload">[32/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8179fc8f4e3e4866c7d8090543e1ca64" name="ga8179fc8f4e3e4866c7d8090543e1ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8179fc8f4e3e4866c7d8090543e1ca64">&#9670;&nbsp;</a></span>attach() <span class="overload">[33/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5d7519564ac923795f8e6bd4328c8fe" name="gad5d7519564ac923795f8e6bd4328c8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5d7519564ac923795f8e6bd4328c8fe">&#9670;&nbsp;</a></span>attach() <span class="overload">[34/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a521721d964cbc427b4bec933cef88b" name="ga1a521721d964cbc427b4bec933cef88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a521721d964cbc427b4bec933cef88b">&#9670;&nbsp;</a></span>attach() <span class="overload">[35/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08d7145bd6021268c4fb5c2edcca1354" name="ga08d7145bd6021268c4fb5c2edcca1354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d7145bd6021268c4fb5c2edcca1354">&#9670;&nbsp;</a></span>attach() <span class="overload">[36/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga282a8fd44b4b8bf13c6877fc7f25819e" name="ga282a8fd44b4b8bf13c6877fc7f25819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282a8fd44b4b8bf13c6877fc7f25819e">&#9670;&nbsp;</a></span>attach() <span class="overload">[37/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a862ee6a2e6d750487268229c3a43a2" name="ga2a862ee6a2e6d750487268229c3a43a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a862ee6a2e6d750487268229c3a43a2">&#9670;&nbsp;</a></span>attach() <span class="overload">[38/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac585e067da7a90bafa7e2c24cfa6be8d" name="gac585e067da7a90bafa7e2c24cfa6be8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac585e067da7a90bafa7e2c24cfa6be8d">&#9670;&nbsp;</a></span>attach() <span class="overload">[39/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga165dfd87c2d268a2133e1d79a460aa33" name="ga165dfd87c2d268a2133e1d79a460aa33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga165dfd87c2d268a2133e1d79a460aa33">&#9670;&nbsp;</a></span>attach() <span class="overload">[40/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1a1945fd9fdeabf11e1a4b1b497e5f8" name="gac1a1945fd9fdeabf11e1a4b1b497e5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a1945fd9fdeabf11e1a4b1b497e5f8">&#9670;&nbsp;</a></span>attach() <span class="overload">[41/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5951f1aabd0ff74512f0aee11146e34c" name="ga5951f1aabd0ff74512f0aee11146e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5951f1aabd0ff74512f0aee11146e34c">&#9670;&nbsp;</a></span>attach() <span class="overload">[42/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga576f7e13607933ea49c809f7c6920661" name="ga576f7e13607933ea49c809f7c6920661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576f7e13607933ea49c809f7c6920661">&#9670;&nbsp;</a></span>attach() <span class="overload">[43/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga203908b4e78f4d5a816a9ec9ab5ad32d" name="ga203908b4e78f4d5a816a9ec9ab5ad32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203908b4e78f4d5a816a9ec9ab5ad32d">&#9670;&nbsp;</a></span>attach() <span class="overload">[44/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0e18c89e3fa791811090178e8752651" name="gad0e18c89e3fa791811090178e8752651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e18c89e3fa791811090178e8752651">&#9670;&nbsp;</a></span>attach() <span class="overload">[45/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80c0dcf2934f27ba6552cc5ffd69eb7b" name="ga80c0dcf2934f27ba6552cc5ffd69eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c0dcf2934f27ba6552cc5ffd69eb7b">&#9670;&nbsp;</a></span>attach() <span class="overload">[46/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaeb7feeb8dbaa6e064ec64a47f483d7" name="gabaeb7feeb8dbaa6e064ec64a47f483d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaeb7feeb8dbaa6e064ec64a47f483d7">&#9670;&nbsp;</a></span>attach() <span class="overload">[47/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbb147d2bf5978a86a61ebeb51675d60" name="gacbb147d2bf5978a86a61ebeb51675d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb147d2bf5978a86a61ebeb51675d60">&#9670;&nbsp;</a></span>attach() <span class="overload">[48/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8d11d735c6e3c64611af10b582e11a0" name="gac8d11d735c6e3c64611af10b582e11a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8d11d735c6e3c64611af10b582e11a0">&#9670;&nbsp;</a></span>attach() <span class="overload">[49/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0a2cc2dbbd59746c7952ee616c2ad76" name="gaf0a2cc2dbbd59746c7952ee616c2ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a2cc2dbbd59746c7952ee616c2ad76">&#9670;&nbsp;</a></span>attach() <span class="overload">[50/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08640646b88ead8b4bb1f59bf112197e" name="ga08640646b88ead8b4bb1f59bf112197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08640646b88ead8b4bb1f59bf112197e">&#9670;&nbsp;</a></span>attach() <span class="overload">[51/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8d3952588e88280c679af21469e6664" name="gac8d3952588e88280c679af21469e6664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8d3952588e88280c679af21469e6664">&#9670;&nbsp;</a></span>attach() <span class="overload">[52/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ed923ff4526f8e849bd3158515f8178" name="ga3ed923ff4526f8e849bd3158515f8178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed923ff4526f8e849bd3158515f8178">&#9670;&nbsp;</a></span>attach() <span class="overload">[53/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa03b46559d7ada0a944aedd88bd4ad5" name="gaaa03b46559d7ada0a944aedd88bd4ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa03b46559d7ada0a944aedd88bd4ad5">&#9670;&nbsp;</a></span>attach() <span class="overload">[54/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga295cb116c8e83f77e1aa6c646680c630" name="ga295cb116c8e83f77e1aa6c646680c630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga295cb116c8e83f77e1aa6c646680c630">&#9670;&nbsp;</a></span>attach() <span class="overload">[55/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8696d083a12693b4cdc365db92edca3" name="gaa8696d083a12693b4cdc365db92edca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8696d083a12693b4cdc365db92edca3">&#9670;&nbsp;</a></span>attach() <span class="overload">[56/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6de36136736d7bd78fadfd7c8e0a4aab" name="ga6de36136736d7bd78fadfd7c8e0a4aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de36136736d7bd78fadfd7c8e0a4aab">&#9670;&nbsp;</a></span>attach() <span class="overload">[57/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c8fd7e6376db7524ef09994bd7f9efd" name="ga7c8fd7e6376db7524ef09994bd7f9efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c8fd7e6376db7524ef09994bd7f9efd">&#9670;&nbsp;</a></span>attach() <span class="overload">[58/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66aa8dca34b48d1bb59f114503c809fe" name="ga66aa8dca34b48d1bb59f114503c809fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66aa8dca34b48d1bb59f114503c809fe">&#9670;&nbsp;</a></span>attach() <span class="overload">[59/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf411acad8f46e1fdeaa6c72c64f21e39" name="gaf411acad8f46e1fdeaa6c72c64f21e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf411acad8f46e1fdeaa6c72c64f21e39">&#9670;&nbsp;</a></span>attach() <span class="overload">[60/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25fca53c80c2593a12139cffb24ddbca" name="ga25fca53c80c2593a12139cffb24ddbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fca53c80c2593a12139cffb24ddbca">&#9670;&nbsp;</a></span>attach() <span class="overload">[61/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefc28dcb73a90cafa92735dd1e8cfbb4" name="gaefc28dcb73a90cafa92735dd1e8cfbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefc28dcb73a90cafa92735dd1e8cfbb4">&#9670;&nbsp;</a></span>attach() <span class="overload">[62/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga070d4dc97296e88943cb8644ac13c108" name="ga070d4dc97296e88943cb8644ac13c108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070d4dc97296e88943cb8644ac13c108">&#9670;&nbsp;</a></span>attach() <span class="overload">[63/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba3211275a90e584c82ba71739d4df51" name="gaba3211275a90e584c82ba71739d4df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3211275a90e584c82ba71739d4df51">&#9670;&nbsp;</a></span>attach() <span class="overload">[64/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9914b7beed57dca631fcae4a3762e68e" name="ga9914b7beed57dca631fcae4a3762e68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9914b7beed57dca631fcae4a3762e68e">&#9670;&nbsp;</a></span>attach() <span class="overload">[65/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68cb103db1f567f343609b6cc59d6880" name="ga68cb103db1f567f343609b6cc59d6880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68cb103db1f567f343609b6cc59d6880">&#9670;&nbsp;</a></span>attach() <span class="overload">[66/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::attach </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb227bab29aeab78f308d091a1d4b7be" name="gaeb227bab29aeab78f308d091a1d4b7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb227bab29aeab78f308d091a1d4b7be">&#9670;&nbsp;</a></span>attach_rtc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attach_rtc </td>
          <td>(</td>
          <td class="paramtype">time_t(*)(void)&#160;</td>
          <td class="paramname"><em>read_rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(time_t)&#160;</td>
          <td class="paramname"><em>write_rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>init_rtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void)&#160;</td>
          <td class="paramname"><em>isenabled_rtc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach an external RTC to be used for the C time functions</p>
<p >@Note Synchronization level: Thread safe</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_rtc</td><td>pointer to function which returns current UNIX timestamp </td></tr>
    <tr><td class="paramname">write_rtc</td><td>pointer to function which sets current UNIX timestamp, can be NULL </td></tr>
    <tr><td class="paramname">init_rtc</td><td>pointer to funtion which initializes RTC, can be NULL </td></tr>
    <tr><td class="paramname">isenabled_rtc</td><td>pointer to function wich returns if the rtc is enabled, can be NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac911bd44ea0a14da0b0dd46187bf1081" name="gac911bd44ea0a14da0b0dd46187bf1081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac911bd44ea0a14da0b0dd46187bf1081">&#9670;&nbsp;</a></span>call() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed::CallChain::call </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Call all the functions in the chain in sequence </p>

</div>
</div>
<a id="ga71d222c1e13efe443a03379508bcc194" name="ga71d222c1e13efe443a03379508bcc194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d222c1e13efe443a03379508bcc194">&#9670;&nbsp;</a></span>call() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::call </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga8b069cffc0d8849693e970c26ecc9339" name="ga8b069cffc0d8849693e970c26ecc9339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b069cffc0d8849693e970c26ecc9339">&#9670;&nbsp;</a></span>call() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::call </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga3fcaeec6b608e568f05766b4a5a09998" name="ga3fcaeec6b608e568f05766b4a5a09998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fcaeec6b608e568f05766b4a5a09998">&#9670;&nbsp;</a></span>call() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::call </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga0c512a11572d633801561f040bc2a4ee" name="ga0c512a11572d633801561f040bc2a4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c512a11572d633801561f040bc2a4ee">&#9670;&nbsp;</a></span>call() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::call </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga6e440ecbfebd9f45d9a8b777299dcb31" name="ga6e440ecbfebd9f45d9a8b777299dcb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e440ecbfebd9f45d9a8b777299dcb31">&#9670;&nbsp;</a></span>call() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::call </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gaacf6be00579d82fb9668422ee68b878e" name="gaacf6be00579d82fb9668422ee68b878e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf6be00579d82fb9668422ee68b878e">&#9670;&nbsp;</a></span>call() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::call </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga949e0e3768e1063116f68df324c335c2" name="ga949e0e3768e1063116f68df324c335c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949e0e3768e1063116f68df324c335c2">&#9670;&nbsp;</a></span>Callback() <span class="overload">[1/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1701ad270d60caefefbab76f68d1760c" name="ga1701ad270d60caefefbab76f68d1760c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1701ad270d60caefefbab76f68d1760c">&#9670;&nbsp;</a></span>callback() <span class="overload">[1/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gadb14403a450405d7561164132943cb10" name="gadb14403a450405d7561164132943cb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb14403a450405d7561164132943cb10">&#9670;&nbsp;</a></span>Callback() <span class="overload">[2/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc57193c9e173b581700c39cb78627c0" name="gabc57193c9e173b581700c39cb78627c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc57193c9e173b581700c39cb78627c0">&#9670;&nbsp;</a></span>callback() <span class="overload">[2/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga619662f87e37e48596ceb69198dd1080" name="ga619662f87e37e48596ceb69198dd1080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619662f87e37e48596ceb69198dd1080">&#9670;&nbsp;</a></span>Callback() <span class="overload">[3/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38777cfe4734cf78af9db263d55be972" name="ga38777cfe4734cf78af9db263d55be972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38777cfe4734cf78af9db263d55be972">&#9670;&nbsp;</a></span>callback() <span class="overload">[3/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gacb4336f189ca9f689a6ab1c1e271849e" name="gacb4336f189ca9f689a6ab1c1e271849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4336f189ca9f689a6ab1c1e271849e">&#9670;&nbsp;</a></span>Callback() <span class="overload">[4/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d5528182a981ff04f6977d6e2d76a93" name="ga7d5528182a981ff04f6977d6e2d76a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5528182a981ff04f6977d6e2d76a93">&#9670;&nbsp;</a></span>callback() <span class="overload">[4/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga3024fb49d70fa6a9d71f84ef0eb14154" name="ga3024fb49d70fa6a9d71f84ef0eb14154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3024fb49d70fa6a9d71f84ef0eb14154">&#9670;&nbsp;</a></span>Callback() <span class="overload">[5/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33bd6f7ae4bbedb4e6736662b2d3e086" name="ga33bd6f7ae4bbedb4e6736662b2d3e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bd6f7ae4bbedb4e6736662b2d3e086">&#9670;&nbsp;</a></span>callback() <span class="overload">[5/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga63593f9ee9740ba29b8bb32a9f007f06" name="ga63593f9ee9740ba29b8bb32a9f007f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63593f9ee9740ba29b8bb32a9f007f06">&#9670;&nbsp;</a></span>Callback() <span class="overload">[6/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attach a <a class="el" href="classmbed_1_1_callback.html">Callback</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="classmbed_1_1_callback.html">Callback</a> to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85df50dd3a956e552bca6fe4b0f90501" name="ga85df50dd3a956e552bca6fe4b0f90501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85df50dd3a956e552bca6fe4b0f90501">&#9670;&nbsp;</a></span>callback() <span class="overload">[6/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga3de7f6c2997348d27ea825998e88cc15" name="ga3de7f6c2997348d27ea825998e88cc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3de7f6c2997348d27ea825998e88cc15">&#9670;&nbsp;</a></span>Callback() <span class="overload">[7/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cd90bf037410272a91c23963962210c" name="ga0cd90bf037410272a91c23963962210c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd90bf037410272a91c23963962210c">&#9670;&nbsp;</a></span>callback() <span class="overload">[7/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga2ed553cc1e6d6b5547190d3d47e99a0b" name="ga2ed553cc1e6d6b5547190d3d47e99a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed553cc1e6d6b5547190d3d47e99a0b">&#9670;&nbsp;</a></span>Callback() <span class="overload">[8/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e6d698cd8d3988327e040be760ebacf" name="ga9e6d698cd8d3988327e040be760ebacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e6d698cd8d3988327e040be760ebacf">&#9670;&nbsp;</a></span>callback() <span class="overload">[8/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaada5aad0d58a5d868c655ce685224e0f" name="gaada5aad0d58a5d868c655ce685224e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaada5aad0d58a5d868c655ce685224e0f">&#9670;&nbsp;</a></span>Callback() <span class="overload">[9/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae30b7f1f64e1b15b485a60f2b8de7fc9" name="gae30b7f1f64e1b15b485a60f2b8de7fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30b7f1f64e1b15b485a60f2b8de7fc9">&#9670;&nbsp;</a></span>callback() <span class="overload">[9/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga5769654b8cb7a29160737f36fdb8878b" name="ga5769654b8cb7a29160737f36fdb8878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5769654b8cb7a29160737f36fdb8878b">&#9670;&nbsp;</a></span>Callback() <span class="overload">[10/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae06aaededf3704033212f2974ad5fb87" name="gae06aaededf3704033212f2974ad5fb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06aaededf3704033212f2974ad5fb87">&#9670;&nbsp;</a></span>callback() <span class="overload">[10/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga80b8864a63d3abd3ce1b0e1a17bb2c53" name="ga80b8864a63d3abd3ce1b0e1a17bb2c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b8864a63d3abd3ce1b0e1a17bb2c53">&#9670;&nbsp;</a></span>Callback() <span class="overload">[11/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcec10bfd9c27c41399bed7785339e52" name="gafcec10bfd9c27c41399bed7785339e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcec10bfd9c27c41399bed7785339e52">&#9670;&nbsp;</a></span>callback() <span class="overload">[11/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaa3d95d821c020357e310d2605592269f" name="gaa3d95d821c020357e310d2605592269f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d95d821c020357e310d2605592269f">&#9670;&nbsp;</a></span>Callback() <span class="overload">[12/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga633ebeae2024d03038f29e42e6e71bf5" name="ga633ebeae2024d03038f29e42e6e71bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633ebeae2024d03038f29e42e6e71bf5">&#9670;&nbsp;</a></span>callback() <span class="overload">[12/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gab4d482b9784f45f22af35dcb6d22b999" name="gab4d482b9784f45f22af35dcb6d22b999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4d482b9784f45f22af35dcb6d22b999">&#9670;&nbsp;</a></span>Callback() <span class="overload">[13/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15b4017ed78bafecd9536c407369013f" name="ga15b4017ed78bafecd9536c407369013f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b4017ed78bafecd9536c407369013f">&#9670;&nbsp;</a></span>callback() <span class="overload">[13/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga454e1a495babdea8b2d704c27151c949" name="ga454e1a495babdea8b2d704c27151c949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454e1a495babdea8b2d704c27151c949">&#9670;&nbsp;</a></span>Callback() <span class="overload">[14/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f1a4a142d0661b630a3f8e98ca1f902" name="ga0f1a4a142d0661b630a3f8e98ca1f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f1a4a142d0661b630a3f8e98ca1f902">&#9670;&nbsp;</a></span>callback() <span class="overload">[14/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga868fd79b893363e8ea5d9ab957edad2c" name="ga868fd79b893363e8ea5d9ab957edad2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868fd79b893363e8ea5d9ab957edad2c">&#9670;&nbsp;</a></span>Callback() <span class="overload">[15/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed87179a6287c3413f31e886b0745a9c" name="gaed87179a6287c3413f31e886b0745a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed87179a6287c3413f31e886b0745a9c">&#9670;&nbsp;</a></span>callback() <span class="overload">[15/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaa277c6341de692511fd2d9899d1cd83c" name="gaa277c6341de692511fd2d9899d1cd83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa277c6341de692511fd2d9899d1cd83c">&#9670;&nbsp;</a></span>Callback() <span class="overload">[16/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95e9ae992de24e6dc0dbd554634030cc" name="ga95e9ae992de24e6dc0dbd554634030cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e9ae992de24e6dc0dbd554634030cc">&#9670;&nbsp;</a></span>callback() <span class="overload">[16/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gad5e9b02fd316395ac94fcd30537b43f2" name="gad5e9b02fd316395ac94fcd30537b43f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5e9b02fd316395ac94fcd30537b43f2">&#9670;&nbsp;</a></span>Callback() <span class="overload">[17/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1ba70adb8e3e79de7fb7b05c2894655" name="gae1ba70adb8e3e79de7fb7b05c2894655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ba70adb8e3e79de7fb7b05c2894655">&#9670;&nbsp;</a></span>callback() <span class="overload">[17/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaa73af2947c97682fc16fc0eb1210c3ba" name="gaa73af2947c97682fc16fc0eb1210c3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73af2947c97682fc16fc0eb1210c3ba">&#9670;&nbsp;</a></span>Callback() <span class="overload">[18/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a50820affd6130c4c4b8932d29ee51d" name="ga9a50820affd6130c4c4b8932d29ee51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a50820affd6130c4c4b8932d29ee51d">&#9670;&nbsp;</a></span>callback() <span class="overload">[18/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga52ef65d588f9a5547f3099f151a4873e" name="ga52ef65d588f9a5547f3099f151a4873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ef65d588f9a5547f3099f151a4873e">&#9670;&nbsp;</a></span>Callback() <span class="overload">[19/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga66c66e66f4e9f0710c797f2733b22ef4" name="ga66c66e66f4e9f0710c797f2733b22ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c66e66f4e9f0710c797f2733b22ef4">&#9670;&nbsp;</a></span>Callback() <span class="overload">[20/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga57a5f9b9f23a112b837d983fd9e15d71" name="ga57a5f9b9f23a112b837d983fd9e15d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a5f9b9f23a112b837d983fd9e15d71">&#9670;&nbsp;</a></span>Callback() <span class="overload">[21/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="gac6039ea71f2a1c4058723e0c3e273cc9" name="gac6039ea71f2a1c4058723e0c3e273cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6039ea71f2a1c4058723e0c3e273cc9">&#9670;&nbsp;</a></span>Callback() <span class="overload">[22/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="gad29be6d1c7bcc02e82df24fffd018ebc" name="gad29be6d1c7bcc02e82df24fffd018ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad29be6d1c7bcc02e82df24fffd018ebc">&#9670;&nbsp;</a></span>Callback() <span class="overload">[23/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga1b0ea31a72e122a6dcc03e7f173aa4eb" name="ga1b0ea31a72e122a6dcc03e7f173aa4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0ea31a72e122a6dcc03e7f173aa4eb">&#9670;&nbsp;</a></span>Callback() <span class="overload">[24/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a function object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function object is limited to a single word of storage </dd></dl>

</div>
</div>
<a id="ga2e4291df3fcb05da24067c5469edc8ae" name="ga2e4291df3fcb05da24067c5469edc8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4291df3fcb05da24067c5469edc8ae">&#9670;&nbsp;</a></span>Callback() <span class="overload">[25/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79787577174689d1c0c7be04b08fc1d7" name="ga79787577174689d1c0c7be04b08fc1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79787577174689d1c0c7be04b08fc1d7">&#9670;&nbsp;</a></span>callback() <span class="overload">[19/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga26685399a6106a159125524b67312267" name="ga26685399a6106a159125524b67312267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26685399a6106a159125524b67312267">&#9670;&nbsp;</a></span>Callback() <span class="overload">[26/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa42c34c97ac84ef443c927ee60afbc1d" name="gaa42c34c97ac84ef443c927ee60afbc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42c34c97ac84ef443c927ee60afbc1d">&#9670;&nbsp;</a></span>callback() <span class="overload">[20/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gafdac7e3c27de5240ebeca217310c7a17" name="gafdac7e3c27de5240ebeca217310c7a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdac7e3c27de5240ebeca217310c7a17">&#9670;&nbsp;</a></span>Callback() <span class="overload">[27/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fd4e7d3b013591d25525ff29714651e" name="ga9fd4e7d3b013591d25525ff29714651e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fd4e7d3b013591d25525ff29714651e">&#9670;&nbsp;</a></span>callback() <span class="overload">[21/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga12f28dd98e3ddd1254b999d9c854e572" name="ga12f28dd98e3ddd1254b999d9c854e572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f28dd98e3ddd1254b999d9c854e572">&#9670;&nbsp;</a></span>Callback() <span class="overload">[28/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga893c318fb8c3b8b7210c7af76e909ae6" name="ga893c318fb8c3b8b7210c7af76e909ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893c318fb8c3b8b7210c7af76e909ae6">&#9670;&nbsp;</a></span>callback() <span class="overload">[22/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gadcd261da77f5938900df20efcaa2e4f7" name="gadcd261da77f5938900df20efcaa2e4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd261da77f5938900df20efcaa2e4f7">&#9670;&nbsp;</a></span>Callback() <span class="overload">[29/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga956f7b22c272c4573f48d56d82a75610" name="ga956f7b22c272c4573f48d56d82a75610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956f7b22c272c4573f48d56d82a75610">&#9670;&nbsp;</a></span>callback() <span class="overload">[23/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga20825b02c441e6fbf9b8c0da18c63c3b" name="ga20825b02c441e6fbf9b8c0da18c63c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20825b02c441e6fbf9b8c0da18c63c3b">&#9670;&nbsp;</a></span>Callback() <span class="overload">[30/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab61814764ae4b4a4802dd47b290da69f" name="gab61814764ae4b4a4802dd47b290da69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab61814764ae4b4a4802dd47b290da69f">&#9670;&nbsp;</a></span>callback() <span class="overload">[24/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga9c857b7511e5f539b2748f8e4b92f1ef" name="ga9c857b7511e5f539b2748f8e4b92f1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c857b7511e5f539b2748f8e4b92f1ef">&#9670;&nbsp;</a></span>Callback() <span class="overload">[31/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f21d279de2bef76e93b3af4a2bb59c8" name="ga3f21d279de2bef76e93b3af4a2bb59c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f21d279de2bef76e93b3af4a2bb59c8">&#9670;&nbsp;</a></span>callback() <span class="overload">[25/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaf975f1fc65dd39cb57ba2cc38946e0b0" name="gaf975f1fc65dd39cb57ba2cc38946e0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf975f1fc65dd39cb57ba2cc38946e0b0">&#9670;&nbsp;</a></span>Callback() <span class="overload">[32/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga258dc35a2d68be58f584376542df16be" name="ga258dc35a2d68be58f584376542df16be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258dc35a2d68be58f584376542df16be">&#9670;&nbsp;</a></span>callback() <span class="overload">[26/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga7d8c5534e0bbd8b9fdb4838db8193496" name="ga7d8c5534e0bbd8b9fdb4838db8193496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8c5534e0bbd8b9fdb4838db8193496">&#9670;&nbsp;</a></span>Callback() <span class="overload">[33/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3472e49b56c143cf6d221f783983cb82" name="ga3472e49b56c143cf6d221f783983cb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3472e49b56c143cf6d221f783983cb82">&#9670;&nbsp;</a></span>callback() <span class="overload">[27/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga9334dd0d02a68ab1a5f4c0efb5a6cae0" name="ga9334dd0d02a68ab1a5f4c0efb5a6cae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9334dd0d02a68ab1a5f4c0efb5a6cae0">&#9670;&nbsp;</a></span>Callback() <span class="overload">[34/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga886aa59ea250bb96e7fc66974b99045a" name="ga886aa59ea250bb96e7fc66974b99045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga886aa59ea250bb96e7fc66974b99045a">&#9670;&nbsp;</a></span>callback() <span class="overload">[28/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga232dadbf518b40c3fb106f706fd64aa8" name="ga232dadbf518b40c3fb106f706fd64aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga232dadbf518b40c3fb106f706fd64aa8">&#9670;&nbsp;</a></span>Callback() <span class="overload">[35/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9425abebc78baae3a470f5abd501fbd1" name="ga9425abebc78baae3a470f5abd501fbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9425abebc78baae3a470f5abd501fbd1">&#9670;&nbsp;</a></span>callback() <span class="overload">[29/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga13dd878d1091bfe82ba95453095c2f0c" name="ga13dd878d1091bfe82ba95453095c2f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13dd878d1091bfe82ba95453095c2f0c">&#9670;&nbsp;</a></span>Callback() <span class="overload">[36/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ad3f0ce8b1736d861be9c570bf6b1b5" name="ga9ad3f0ce8b1736d861be9c570bf6b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad3f0ce8b1736d861be9c570bf6b1b5">&#9670;&nbsp;</a></span>callback() <span class="overload">[30/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gac188b72cd4d7ba7bbf4b66f9679d4429" name="gac188b72cd4d7ba7bbf4b66f9679d4429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac188b72cd4d7ba7bbf4b66f9679d4429">&#9670;&nbsp;</a></span>Callback() <span class="overload">[37/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31e3ad3a0bf803414400c4016a07becf" name="ga31e3ad3a0bf803414400c4016a07becf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e3ad3a0bf803414400c4016a07becf">&#9670;&nbsp;</a></span>callback() <span class="overload">[31/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga20acb1c81a442714971e29abca9f45f3" name="ga20acb1c81a442714971e29abca9f45f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20acb1c81a442714971e29abca9f45f3">&#9670;&nbsp;</a></span>Callback() <span class="overload">[38/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga585bd1d191125de31151106e9e69b407" name="ga585bd1d191125de31151106e9e69b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585bd1d191125de31151106e9e69b407">&#9670;&nbsp;</a></span>callback() <span class="overload">[32/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gae3e2a2fa43a4b0c5179f09a6a31742c2" name="gae3e2a2fa43a4b0c5179f09a6a31742c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e2a2fa43a4b0c5179f09a6a31742c2">&#9670;&nbsp;</a></span>Callback() <span class="overload">[39/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e6237c2220c9df4ad188a3e6550647b" name="ga1e6237c2220c9df4ad188a3e6550647b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6237c2220c9df4ad188a3e6550647b">&#9670;&nbsp;</a></span>callback() <span class="overload">[33/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga8226e4e0176acb5685e1c1d91098e8e3" name="ga8226e4e0176acb5685e1c1d91098e8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8226e4e0176acb5685e1c1d91098e8e3">&#9670;&nbsp;</a></span>Callback() <span class="overload">[40/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19ad8730eba2e5d12f41bcf588b06a5c" name="ga19ad8730eba2e5d12f41bcf588b06a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ad8730eba2e5d12f41bcf588b06a5c">&#9670;&nbsp;</a></span>callback() <span class="overload">[34/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga15109359d3989205c2f8e1cf740c7805" name="ga15109359d3989205c2f8e1cf740c7805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15109359d3989205c2f8e1cf740c7805">&#9670;&nbsp;</a></span>Callback() <span class="overload">[41/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48a08cdd23defe7e16283edf0b1f0c9e" name="ga48a08cdd23defe7e16283edf0b1f0c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48a08cdd23defe7e16283edf0b1f0c9e">&#9670;&nbsp;</a></span>callback() <span class="overload">[35/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gabd26c568b29fdc1090ea2a384ba4eb32" name="gabd26c568b29fdc1090ea2a384ba4eb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd26c568b29fdc1090ea2a384ba4eb32">&#9670;&nbsp;</a></span>Callback() <span class="overload">[42/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48c9ab82acf82693e1cbedd5efc14933" name="ga48c9ab82acf82693e1cbedd5efc14933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c9ab82acf82693e1cbedd5efc14933">&#9670;&nbsp;</a></span>callback() <span class="overload">[36/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gade0b470505f38c2732839c4ee4c673ea" name="gade0b470505f38c2732839c4ee4c673ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade0b470505f38c2732839c4ee4c673ea">&#9670;&nbsp;</a></span>Callback() <span class="overload">[43/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga071229ea2c15481c2cb6a48fc9dbd2a8" name="ga071229ea2c15481c2cb6a48fc9dbd2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071229ea2c15481c2cb6a48fc9dbd2a8">&#9670;&nbsp;</a></span>callback() <span class="overload">[37/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gab9b33c1983392cba4afc6edc972fde9c" name="gab9b33c1983392cba4afc6edc972fde9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b33c1983392cba4afc6edc972fde9c">&#9670;&nbsp;</a></span>Callback() <span class="overload">[44/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b818e85af8edc98cbac8f8645fbb848" name="ga1b818e85af8edc98cbac8f8645fbb848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b818e85af8edc98cbac8f8645fbb848">&#9670;&nbsp;</a></span>callback() <span class="overload">[38/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga4753d73ddc29c3bb9c1763a44fccd7b4" name="ga4753d73ddc29c3bb9c1763a44fccd7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4753d73ddc29c3bb9c1763a44fccd7b4">&#9670;&nbsp;</a></span>Callback() <span class="overload">[45/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ad466e7f91058dea8c57aef27ff40c9" name="ga2ad466e7f91058dea8c57aef27ff40c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad466e7f91058dea8c57aef27ff40c9">&#9670;&nbsp;</a></span>callback() <span class="overload">[39/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga0866d4f19d0ed1b7a36f683c215579f9" name="ga0866d4f19d0ed1b7a36f683c215579f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0866d4f19d0ed1b7a36f683c215579f9">&#9670;&nbsp;</a></span>Callback() <span class="overload">[46/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad52516fa0337ec89d24f35783562da21" name="gad52516fa0337ec89d24f35783562da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52516fa0337ec89d24f35783562da21">&#9670;&nbsp;</a></span>callback() <span class="overload">[40/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaa0377b1afb4326b54828761d3a207d2e" name="gaa0377b1afb4326b54828761d3a207d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0377b1afb4326b54828761d3a207d2e">&#9670;&nbsp;</a></span>Callback() <span class="overload">[47/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga467859b73e3d8d6629943b983734c20b" name="ga467859b73e3d8d6629943b983734c20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga467859b73e3d8d6629943b983734c20b">&#9670;&nbsp;</a></span>callback() <span class="overload">[41/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga4cd63df22ffa1ff680e5742ba9004e2d" name="ga4cd63df22ffa1ff680e5742ba9004e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd63df22ffa1ff680e5742ba9004e2d">&#9670;&nbsp;</a></span>Callback() <span class="overload">[48/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4477f99971a99df425de8905a8cd39bb" name="ga4477f99971a99df425de8905a8cd39bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4477f99971a99df425de8905a8cd39bb">&#9670;&nbsp;</a></span>callback() <span class="overload">[42/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga4ce19ed4c80e12a15a8cc4235ab78fe5" name="ga4ce19ed4c80e12a15a8cc4235ab78fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ce19ed4c80e12a15a8cc4235ab78fe5">&#9670;&nbsp;</a></span>Callback() <span class="overload">[49/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae3ca2401eb8ba233f15006d7f87ee6a" name="gaae3ca2401eb8ba233f15006d7f87ee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae3ca2401eb8ba233f15006d7f87ee6a">&#9670;&nbsp;</a></span>callback() <span class="overload">[43/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga1c108754a2264a07abc7590b26d81979" name="ga1c108754a2264a07abc7590b26d81979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c108754a2264a07abc7590b26d81979">&#9670;&nbsp;</a></span>Callback() <span class="overload">[50/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad733151963f94f8ff104fe600640465f" name="gad733151963f94f8ff104fe600640465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad733151963f94f8ff104fe600640465f">&#9670;&nbsp;</a></span>callback() <span class="overload">[44/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga1cf8cd388813ca592e14f7bae771aebd" name="ga1cf8cd388813ca592e14f7bae771aebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf8cd388813ca592e14f7bae771aebd">&#9670;&nbsp;</a></span>Callback() <span class="overload">[51/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac16c56c90ed9b15dddbc92b5f9d7c637" name="gac16c56c90ed9b15dddbc92b5f9d7c637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac16c56c90ed9b15dddbc92b5f9d7c637">&#9670;&nbsp;</a></span>callback() <span class="overload">[45/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gae5c46df32895c79e9c05b862a4b08003" name="gae5c46df32895c79e9c05b862a4b08003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c46df32895c79e9c05b862a4b08003">&#9670;&nbsp;</a></span>Callback() <span class="overload">[52/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf8977070245ca4b6f889ee9c6f98272" name="gaaf8977070245ca4b6f889ee9c6f98272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8977070245ca4b6f889ee9c6f98272">&#9670;&nbsp;</a></span>callback() <span class="overload">[46/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga2aa2c6a75d7eb0651b285661454870e5" name="ga2aa2c6a75d7eb0651b285661454870e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aa2c6a75d7eb0651b285661454870e5">&#9670;&nbsp;</a></span>Callback() <span class="overload">[53/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga684fc9526d04b2b95cde07200cae8aec" name="ga684fc9526d04b2b95cde07200cae8aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga684fc9526d04b2b95cde07200cae8aec">&#9670;&nbsp;</a></span>callback() <span class="overload">[47/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga7afbf0a4df52cdf67ba4c5e193277008" name="ga7afbf0a4df52cdf67ba4c5e193277008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afbf0a4df52cdf67ba4c5e193277008">&#9670;&nbsp;</a></span>Callback() <span class="overload">[54/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a61b2468eb9481fa2f206fef03613b9" name="ga7a61b2468eb9481fa2f206fef03613b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a61b2468eb9481fa2f206fef03613b9">&#9670;&nbsp;</a></span>callback() <span class="overload">[48/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaba8364dab1cf66c4560bf8f22ff9aaf2" name="gaba8364dab1cf66c4560bf8f22ff9aaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8364dab1cf66c4560bf8f22ff9aaf2">&#9670;&nbsp;</a></span>Callback() <span class="overload">[55/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa56bd70769446943c650be3871120c17" name="gaa56bd70769446943c650be3871120c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56bd70769446943c650be3871120c17">&#9670;&nbsp;</a></span>callback() <span class="overload">[49/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gac487301efd13f7927ca1d1d5685187cd" name="gac487301efd13f7927ca1d1d5685187cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac487301efd13f7927ca1d1d5685187cd">&#9670;&nbsp;</a></span>Callback() <span class="overload">[56/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22e9edd2ec8c4a38d3d81b13d8dc8dc5" name="ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e9edd2ec8c4a38d3d81b13d8dc8dc5">&#9670;&nbsp;</a></span>callback() <span class="overload">[50/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaedad5979a6ecc5a841e999f56f54210f" name="gaedad5979a6ecc5a841e999f56f54210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedad5979a6ecc5a841e999f56f54210f">&#9670;&nbsp;</a></span>Callback() <span class="overload">[57/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga249bfa303889a67671725a58ffb975fb" name="ga249bfa303889a67671725a58ffb975fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249bfa303889a67671725a58ffb975fb">&#9670;&nbsp;</a></span>callback() <span class="overload">[51/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaa2edb51597b8140e71f4862a815a62ab" name="gaa2edb51597b8140e71f4862a815a62ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2edb51597b8140e71f4862a815a62ab">&#9670;&nbsp;</a></span>Callback() <span class="overload">[58/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4dd68cc0f404703de25bca4121852215" name="ga4dd68cc0f404703de25bca4121852215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd68cc0f404703de25bca4121852215">&#9670;&nbsp;</a></span>callback() <span class="overload">[52/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaad199dd0b7f13956dadbd2c78068bbff" name="gaad199dd0b7f13956dadbd2c78068bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad199dd0b7f13956dadbd2c78068bbff">&#9670;&nbsp;</a></span>Callback() <span class="overload">[59/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf69fc2a2c3bf9b8ea95259b568e4c45" name="gadf69fc2a2c3bf9b8ea95259b568e4c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf69fc2a2c3bf9b8ea95259b568e4c45">&#9670;&nbsp;</a></span>callback() <span class="overload">[53/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gae016caa48f77914c69cd880730182c58" name="gae016caa48f77914c69cd880730182c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae016caa48f77914c69cd880730182c58">&#9670;&nbsp;</a></span>Callback() <span class="overload">[60/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40c8ef76d1ef9ad360c39d1a877895b6" name="ga40c8ef76d1ef9ad360c39d1a877895b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c8ef76d1ef9ad360c39d1a877895b6">&#9670;&nbsp;</a></span>callback() <span class="overload">[54/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga0c0445cde874065854de9f1b971e4e6a" name="ga0c0445cde874065854de9f1b971e4e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c0445cde874065854de9f1b971e4e6a">&#9670;&nbsp;</a></span>Callback() <span class="overload">[61/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69ed43c201888cf9062330471480bf34" name="ga69ed43c201888cf9062330471480bf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ed43c201888cf9062330471480bf34">&#9670;&nbsp;</a></span>callback() <span class="overload">[55/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga8592aff9c017394291d36a04434a745d" name="ga8592aff9c017394291d36a04434a745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8592aff9c017394291d36a04434a745d">&#9670;&nbsp;</a></span>Callback() <span class="overload">[62/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga555e63c5df84b0cfff5f07cfbdb9502f" name="ga555e63c5df84b0cfff5f07cfbdb9502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555e63c5df84b0cfff5f07cfbdb9502f">&#9670;&nbsp;</a></span>callback() <span class="overload">[56/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga92f8e26973c1553834fedb64f4bfb9be" name="ga92f8e26973c1553834fedb64f4bfb9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f8e26973c1553834fedb64f4bfb9be">&#9670;&nbsp;</a></span>Callback() <span class="overload">[63/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a07ae1a7775c694f82595ad4da5fabf" name="ga0a07ae1a7775c694f82595ad4da5fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a07ae1a7775c694f82595ad4da5fabf">&#9670;&nbsp;</a></span>callback() <span class="overload">[57/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="gaab4bfc5ab6980bd89851571e8ad861ec" name="gaab4bfc5ab6980bd89851571e8ad861ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4bfc5ab6980bd89851571e8ad861ec">&#9670;&nbsp;</a></span>Callback() <span class="overload">[64/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab67ac071dd83fcfa7dca895334fd7d62" name="gab67ac071dd83fcfa7dca895334fd7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67ac071dd83fcfa7dca895334fd7d62">&#9670;&nbsp;</a></span>callback() <span class="overload">[58/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga2cbe08f1ab210c7768d5dfb7ca853876" name="ga2cbe08f1ab210c7768d5dfb7ca853876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbe08f1ab210c7768d5dfb7ca853876">&#9670;&nbsp;</a></span>Callback() <span class="overload">[65/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe12e4221e4d09ed112f0c88e2dacb12" name="gafe12e4221e4d09ed112f0c88e2dacb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe12e4221e4d09ed112f0c88e2dacb12">&#9670;&nbsp;</a></span>callback() <span class="overload">[59/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga9534573cf0c4a7842345e29887005155" name="ga9534573cf0c4a7842345e29887005155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9534573cf0c4a7842345e29887005155">&#9670;&nbsp;</a></span>Callback() <span class="overload">[66/66]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a member function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to invoke member function on </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7552a7b7668edfa77c5230504170642a" name="ga7552a7b7668edfa77c5230504170642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7552a7b7668edfa77c5230504170642a">&#9670;&nbsp;</a></span>callback() <span class="overload">[60/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>

</div>
</div>
<a id="ga01b2b14e23b60c4d81522b19ef04cd9b" name="ga01b2b14e23b60c4d81522b19ef04cd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01b2b14e23b60c4d81522b19ef04cd9b">&#9670;&nbsp;</a></span>CallChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mbed::CallChain::CallChain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>4</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create an empty chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>(optional) Initial size of the chain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65693758d2e75e3390e64d27b98556c2" name="ga65693758d2e75e3390e64d27b98556c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65693758d2e75e3390e64d27b98556c2">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed::CallChain::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clear the call chain (remove all functions in the chain). </p>

</div>
</div>
<a id="ga44e8efe109debaecb97353942640531d" name="ga44e8efe109debaecb97353942640531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44e8efe109debaecb97353942640531d">&#9670;&nbsp;</a></span>core_util_are_interrupts_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_are_interrupts_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine the current interrupts enabled state</p>
<p >This function can be called to determine whether or not interrupts are currently enabled. </p><dl class="section note"><dt>Note</dt><dd>NOTE: This function works for both cortex-A and cortex-M, although the underlyng implementation differs. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if interrupts are enabled, false otherwise </dd></dl>

</div>
</div>
<a id="ga998af6df4c50b0e05397144d3a162ce6" name="ga998af6df4c50b0e05397144d3a162ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga998af6df4c50b0e05397144d3a162ce6">&#9670;&nbsp;</a></span>core_util_atomic_cas_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_ptr </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. @Note: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<p >@Note: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is still updated with the current value. This property helps writing concise code for the following incr:</p>
<p >function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a } </p>

</div>
</div>
<a id="ga1dce10ba94bce93c711b9547b33323f6" name="ga1dce10ba94bce93c711b9547b33323f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dce10ba94bce93c711b9547b33323f6">&#9670;&nbsp;</a></span>core_util_atomic_cas_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. @Note: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<p >@Note: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is still updated with the current value. This property helps writing concise code for the following incr:</p>
<p >function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a } </p>

</div>
</div>
<a id="gaef3e2741e98d541f996fa05d64e4f6f7" name="gaef3e2741e98d541f996fa05d64e4f6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef3e2741e98d541f996fa05d64e4f6f7">&#9670;&nbsp;</a></span>core_util_atomic_cas_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. @Note: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<p >@Note: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is still updated with the current value. This property helps writing concise code for the following incr:</p>
<p >function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a } </p>

</div>
</div>
<a id="gad2da9a3507c0b348c788ec33a4002427" name="gad2da9a3507c0b348c788ec33a4002427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2da9a3507c0b348c788ec33a4002427">&#9670;&nbsp;</a></span>core_util_atomic_cas_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. @Note: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<p >@Note: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is still updated with the current value. This property helps writing concise code for the following incr:</p>
<p >function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a } </p>

</div>
</div>
<a id="ga839a89f0bd3f1a3227ed7771be1f1b29" name="ga839a89f0bd3f1a3227ed7771be1f1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839a89f0bd3f1a3227ed7771be1f1b29">&#9670;&nbsp;</a></span>core_util_atomic_decr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_decr_ptr </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The type of the pointer argument is not taken into account and the pointer is decremented by bytes </dd></dl>

</div>
</div>
<a id="gadc455724a1bbdbbdbfb54f2b80887d7c" name="gadc455724a1bbdbbdbfb54f2b80887d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc455724a1bbdbbdbfb54f2b80887d7c">&#9670;&nbsp;</a></span>core_util_atomic_decr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_decr_u16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga347c5567d9e5fcc04c9ffa62acecac7d" name="ga347c5567d9e5fcc04c9ffa62acecac7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347c5567d9e5fcc04c9ffa62acecac7d">&#9670;&nbsp;</a></span>core_util_atomic_decr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_decr_u32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="gac6a0c9bc7e4ab8f0d3274c518dc5bcd7" name="gac6a0c9bc7e4ab8f0d3274c518dc5bcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a0c9bc7e4ab8f0d3274c518dc5bcd7">&#9670;&nbsp;</a></span>core_util_atomic_decr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_decr_u8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga332b9bdb03ba39b34dc69d132b80fe8f" name="ga332b9bdb03ba39b34dc69d132b80fe8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332b9bdb03ba39b34dc69d132b80fe8f">&#9670;&nbsp;</a></span>core_util_atomic_incr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_incr_ptr </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The type of the pointer argument is not taken into account and the pointer is incremented by bytes. </dd></dl>

</div>
</div>
<a id="gadf639e19faa639bf886a2a7dae8dd5bc" name="gadf639e19faa639bf886a2a7dae8dd5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf639e19faa639bf886a2a7dae8dd5bc">&#9670;&nbsp;</a></span>core_util_atomic_incr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_incr_u16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga266f82819c467e868a6160cfcff66f20" name="ga266f82819c467e868a6160cfcff66f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga266f82819c467e868a6160cfcff66f20">&#9670;&nbsp;</a></span>core_util_atomic_incr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_incr_u32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga993f6c456b9518a49bfbb96f19115646" name="ga993f6c456b9518a49bfbb96f19115646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga993f6c456b9518a49bfbb96f19115646">&#9670;&nbsp;</a></span>core_util_atomic_incr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_incr_u8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga4d950b3bb0026db2d01df0efd5f18f66" name="ga4d950b3bb0026db2d01df0efd5f18f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d950b3bb0026db2d01df0efd5f18f66">&#9670;&nbsp;</a></span>core_util_critical_section_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_critical_section_enter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark the start of a critical section</p>
<p >This function should be called to mark the start of a critical section of code. </p><dl class="section note"><dt>Note</dt><dd>NOTES: 1) The use of this style of critical section is targetted at C based implementations. 2) These critical sections can be nested. 3) The interrupt enable state on entry to the first critical section (of a nested set, or single section) will be preserved on exit from the section. 4) This implementation will currently only work on code running in privileged mode. </dd></dl>

</div>
</div>
<a id="ga9fbfbd322e41f1f0709332af8c3afc52" name="ga9fbfbd322e41f1f0709332af8c3afc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbfbd322e41f1f0709332af8c3afc52">&#9670;&nbsp;</a></span>core_util_critical_section_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_critical_section_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark the end of a critical section</p>
<p >This function should be called to mark the end of a critical section of code. </p><dl class="section note"><dt>Note</dt><dd>NOTES: 1) The use of this style of critical section is targetted at C based implementations. 2) These critical sections can be nested. 3) The interrupt enable state on entry to the first critical section (of a nested set, or single section) will be preserved on exit from the section. 4) This implementation will currently only work on code running in privileged mode. </dd></dl>

</div>
</div>
<a id="ga3d5c033b92daa3d0575702d3f0d9464d" name="ga3d5c033b92daa3d0575702d3f0d9464d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d5c033b92daa3d0575702d3f0d9464d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , uint32_t BufferSize, typename CounterType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer</a>&lt; T, BufferSize, CounterType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if the buffer is empty</p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer is empty, false if not </dd></dl>

</div>
</div>
<a id="ga5881f835f221141fcf49ab9cb9aae5bd" name="ga5881f835f221141fcf49ab9cb9aae5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5881f835f221141fcf49ab9cb9aae5bd">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbed::CallChain::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Look for a function object in the call chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function object to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the function object if found, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a" name="ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662aaf4fa7ef4e7aa0b9ee0d4a8e4f7a">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , uint32_t BufferSize, typename CounterType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer</a>&lt; T, BufferSize, CounterType &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if the buffer is full</p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer is full, false if not </dd></dl>

</div>
</div>
<a id="gabea593f2dfc6d6e8dd5bb323eff6adab" name="gabea593f2dfc6d6e8dd5bb323eff6adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabea593f2dfc6d6e8dd5bb323eff6adab">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a> mbed::CallChain::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a function object from the chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>function object index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function object at position 'i' in the chain </dd></dl>

</div>
</div>
<a id="gab6d778331549f8485cbea11de1863ab7" name="gab6d778331549f8485cbea11de1863ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d778331549f8485cbea11de1863ab7">&#9670;&nbsp;</a></span>get_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Class * <a class="el" href="classmbed_1_1_transaction.html">mbed::Transaction</a>&lt; Class &gt;::get_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get object's instance for the transaction</p>
<dl class="section return"><dt>Returns</dt><dd>The object which was stored </dd></dl>

</div>
</div>
<a id="ga25aa48d87dedca391051fb85352f99b1" name="ga25aa48d87dedca391051fb85352f99b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25aa48d87dedca391051fb85352f99b1">&#9670;&nbsp;</a></span>get_transaction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbed_1_1transaction__t.html">transaction_t</a> * <a class="el" href="classmbed_1_1_transaction.html">mbed::Transaction</a>&lt; Class &gt;::get_transaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the transaction</p>
<dl class="section return"><dt>Returns</dt><dd>The transaction which was stored </dd></dl>

</div>
</div>
<a id="ga541eb099008f2c2c095391db5ecb6713" name="ga541eb099008f2c2c095391db5ecb6713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541eb099008f2c2c095391db5ecb6713">&#9670;&nbsp;</a></span>mbed_assert_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_assert_internal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internal mbed assert function which is invoked when MBED_ASSERT macro failes. This function is active only if NDEBUG is not defined prior to including this assert header file. In case of MBED_ASSERT failing condition, error() is called with the assertation message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expresion to be checked. </td></tr>
    <tr><td class="paramname">file</td><td>File where assertation failed. </td></tr>
    <tr><td class="paramname">line</td><td>Failing assertation line number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25ad7cff4866522574aba696c07220fd" name="ga25ad7cff4866522574aba696c07220fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ad7cff4866522574aba696c07220fd">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[1/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga34090f1d90ef7ba694950264d688a67b" name="ga34090f1d90ef7ba694950264d688a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34090f1d90ef7ba694950264d688a67b">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[2/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga71ca1084295f482d158d174e26f52bc0" name="ga71ca1084295f482d158d174e26f52bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ca1084295f482d158d174e26f52bc0">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[3/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga4f104f47ab5e34a0662f2194daebb58e" name="ga4f104f47ab5e34a0662f2194daebb58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f104f47ab5e34a0662f2194daebb58e">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[4/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga91f2da4e71a2bab2ddd4d07b7096210f" name="ga91f2da4e71a2bab2ddd4d07b7096210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f2da4e71a2bab2ddd4d07b7096210f">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[5/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga2e28ee4d18429fcec7e82e7f37dcce89" name="ga2e28ee4d18429fcec7e82e7f37dcce89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e28ee4d18429fcec7e82e7f37dcce89">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[6/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga88e190a3f4a04f84213d006bed8c1abc" name="ga88e190a3f4a04f84213d006bed8c1abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e190a3f4a04f84213d006bed8c1abc">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[7/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga31f4c9445933344b6031e5f803faf038" name="ga31f4c9445933344b6031e5f803faf038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f4c9445933344b6031e5f803faf038">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[8/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga69929079b4f2a1eb42678c75dc1633dd" name="ga69929079b4f2a1eb42678c75dc1633dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69929079b4f2a1eb42678c75dc1633dd">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[9/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gaaea2ec1cd60c18a08927aa6e29a1d5df" name="gaaea2ec1cd60c18a08927aa6e29a1d5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea2ec1cd60c18a08927aa6e29a1d5df">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[10/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gab4f6578d65354617b7252894ed7571b4" name="gab4f6578d65354617b7252894ed7571b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f6578d65354617b7252894ed7571b4">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[11/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gae73ccefa8e61b7f5ae30dbf2c130a826" name="gae73ccefa8e61b7f5ae30dbf2c130a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae73ccefa8e61b7f5ae30dbf2c130a826">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[12/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga071fc43ebc9b0de5bad35a174b9fd026" name="ga071fc43ebc9b0de5bad35a174b9fd026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071fc43ebc9b0de5bad35a174b9fd026">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[13/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gae4ea550c7ac335ddaf5d6f6fdce23439" name="gae4ea550c7ac335ddaf5d6f6fdce23439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ea550c7ac335ddaf5d6f6fdce23439">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[14/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gaa45a973d609ff9d9586f17bae0d9b040" name="gaa45a973d609ff9d9586f17bae0d9b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45a973d609ff9d9586f17bae0d9b040">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[15/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gabca0bf587a34ccd9c93554871d17ca74" name="gabca0bf587a34ccd9c93554871d17ca74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabca0bf587a34ccd9c93554871d17ca74">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[16/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gaa62d1e789da4a5e711aea048267d76f7" name="gaa62d1e789da4a5e711aea048267d76f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62d1e789da4a5e711aea048267d76f7">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[17/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gaa9e56772bf13895daa7323379ccf221e" name="gaa9e56772bf13895daa7323379ccf221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e56772bf13895daa7323379ccf221e">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[18/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gab57299076676f942345a81f596dabfc6" name="gab57299076676f942345a81f596dabfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57299076676f942345a81f596dabfc6">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[19/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga4e8526e1baef1ea1a7225ce7b22aad70">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga81d24fec244d0f05e3f9c0bce94e1de4" name="ga81d24fec244d0f05e3f9c0bce94e1de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d24fec244d0f05e3f9c0bce94e1de4">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[20/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#gabb5c0e18f6f21537ab1b5e39c5c66ed2">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gadf2b2594c67a4f1025aec4662f2fc410" name="gadf2b2594c67a4f1025aec4662f2fc410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2b2594c67a4f1025aec4662f2fc410">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[21/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga9e92272a770036c4e598a19418ae1ed5">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga1188d5e327185d5401d30a9f67a8807e" name="ga1188d5e327185d5401d30a9f67a8807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1188d5e327185d5401d30a9f67a8807e">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[22/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga04ca78ed9faf734c6f6e78d2f5d85dd6">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga61d9baeffb825ae0b048fbc34c2b5df5" name="ga61d9baeffb825ae0b048fbc34c2b5df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d9baeffb825ae0b048fbc34c2b5df5">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[23/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga313f9560bc2f37a8e26f3d34e281d567">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="ga4251837ff1a8dbb52763d9bd3c6bd486" name="ga4251837ff1a8dbb52763d9bd3c6bd486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4251837ff1a8dbb52763d9bd3c6bd486">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[24/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="group__platform.html#ga905e914bb0d8f98948c3cc670f288536">attach</a>(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attach a static function with a bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to attach(func, arg) </dd></dl>

</div>
</div>
<a id="gafb0a513642fbe59ab50ddb2734c77f73" name="gafb0a513642fbe59ab50ddb2734c77f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb0a513642fbe59ab50ddb2734c77f73">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[25/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga7cb411b675573ea86c84da568415b475" name="ga7cb411b675573ea86c84da568415b475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb411b675573ea86c84da568415b475">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[26/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga0e3d51f3cd35eaa5c2cb3765692bbdbe" name="ga0e3d51f3cd35eaa5c2cb3765692bbdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e3d51f3cd35eaa5c2cb3765692bbdbe">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[27/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga2ffdb972f88f0263a5779715a51aa129" name="ga2ffdb972f88f0263a5779715a51aa129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ffdb972f88f0263a5779715a51aa129">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[28/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gadfcf9ce35a49f94f07c221595feaddfb" name="gadfcf9ce35a49f94f07c221595feaddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfcf9ce35a49f94f07c221595feaddfb">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[29/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga24469000cdf4f700a1aa06082240b3f8" name="ga24469000cdf4f700a1aa06082240b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24469000cdf4f700a1aa06082240b3f8">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[30/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga50987fd79c66fbf978f10836292cb2cc" name="ga50987fd79c66fbf978f10836292cb2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50987fd79c66fbf978f10836292cb2cc">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[31/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gafb57be8b1d0b6e65c65f1e194c691b82" name="gafb57be8b1d0b6e65c65f1e194c691b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb57be8b1d0b6e65c65f1e194c691b82">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[32/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gabacfb0f40d4af6920dd164e693327876" name="gabacfb0f40d4af6920dd164e693327876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacfb0f40d4af6920dd164e693327876">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[33/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga142c510c60e0008408802ee837989823" name="ga142c510c60e0008408802ee837989823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga142c510c60e0008408802ee837989823">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[34/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga54306aa2ec5084666acf90896903eb43" name="ga54306aa2ec5084666acf90896903eb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54306aa2ec5084666acf90896903eb43">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[35/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gafc7338fbe9d197903b463eabcc63b3aa" name="gafc7338fbe9d197903b463eabcc63b3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7338fbe9d197903b463eabcc63b3aa">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[36/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga4df074a83438de8c950839a78025c3df" name="ga4df074a83438de8c950839a78025c3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df074a83438de8c950839a78025c3df">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[37/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga28ac891a5d744bbd03bd590cb7b2a8fc" name="ga28ac891a5d744bbd03bd590cb7b2a8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ac891a5d744bbd03bd590cb7b2a8fc">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[38/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga2b12313c1b808898616163599b5f05da" name="ga2b12313c1b808898616163599b5f05da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b12313c1b808898616163599b5f05da">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[39/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gaf8b27ed432ab0bf0b713d9292cc6ce9c" name="gaf8b27ed432ab0bf0b713d9292cc6ce9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8b27ed432ab0bf0b713d9292cc6ce9c">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[40/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gac50b0d4161c6bd0708a0d57bcfe41a2e" name="gac50b0d4161c6bd0708a0d57bcfe41a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50b0d4161c6bd0708a0d57bcfe41a2e">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[41/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga2cf531a6ae3477bd58c97f25de9e3d8b" name="ga2cf531a6ae3477bd58c97f25de9e3d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf531a6ae3477bd58c97f25de9e3d8b">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[42/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gabac0170de25fbd7013957744b4022e55" name="gabac0170de25fbd7013957744b4022e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac0170de25fbd7013957744b4022e55">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[43/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga78d12ff1e5d6642999ccbe9cd1f9e9fc" name="ga78d12ff1e5d6642999ccbe9cd1f9e9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d12ff1e5d6642999ccbe9cd1f9e9fc">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[44/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gae06111eb213ae177ab2c945e23f7323a" name="gae06111eb213ae177ab2c945e23f7323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06111eb213ae177ab2c945e23f7323a">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[45/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gad191f405a4c47ca81c9269973b07849f" name="gad191f405a4c47ca81c9269973b07849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad191f405a4c47ca81c9269973b07849f">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[46/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga0d7ba95f6b6ba83aacf25f853284ef38" name="ga0d7ba95f6b6ba83aacf25f853284ef38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d7ba95f6b6ba83aacf25f853284ef38">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[47/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="gaad9b60868a69920a80610a513b7da4ac" name="gaad9b60868a69920a80610a513b7da4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad9b60868a69920a80610a513b7da4ac">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[48/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> volatile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a <a class="el" href="classmbed_1_1_callback.html">Callback</a> with a static function and bound pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to Callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga598e97b15c4d90f94aa1d1668d5cdcd0" name="ga598e97b15c4d90f94aa1d1668d5cdcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598e97b15c4d90f94aa1d1668d5cdcd0">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[49/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga44f9e781941d03580345c71175307b53" name="ga44f9e781941d03580345c71175307b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f9e781941d03580345c71175307b53">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[50/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga10bb79c4ef863bc9917cbf446d7d0568" name="ga10bb79c4ef863bc9917cbf446d7d0568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10bb79c4ef863bc9917cbf446d7d0568">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[51/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="gae58d69f185c10e920930a5dd1aebeca4" name="gae58d69f185c10e920930a5dd1aebeca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58d69f185c10e920930a5dd1aebeca4">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[52/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga523a7324cf927bf9614efeb64c557d66" name="ga523a7324cf927bf9614efeb64c557d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523a7324cf927bf9614efeb64c557d66">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[53/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga301526d02ad11b9014ffd1e03bc577b9" name="ga301526d02ad11b9014ffd1e03bc577b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301526d02ad11b9014ffd1e03bc577b9">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[54/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type infered from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with infered type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="gaf7d3c8fc4c6e97a38eb512ef131d631e" name="gaf7d3c8fc4c6e97a38eb512ef131d631e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d3c8fc4c6e97a38eb512ef131d631e">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[55/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::CallChain::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The <a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a> function does not support cv-qualifiers. Replaced by &quot; &quot;<a class="el" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(callback(obj, method)).&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a function at the end of the chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>pointer to the object to call the member function on </td></tr>
    <tr><td class="paramname">method</td><td>pointer to the member function to be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function object created for 'obj' and 'method'</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>The add function does not support cv-qualifiers. Replaced by add(callback(obj, method)). </dd></dl>

</div>
</div>
<a id="ga7fe1c726069fc595b3b669e2b7faef02" name="ga7fe1c726069fc595b3b669e2b7faef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe1c726069fc595b3b669e2b7faef02">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[56/56]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::CallChain::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The <a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a> function does not support cv-qualifiers. Replaced by &quot; &quot;<a class="el" href="group__platform.html#ga8784da11faa09b23c7e290ce3326d10a">add_front</a>(callback(obj, method)).&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a function at the beginning of the chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tptr</td><td>pointer to the object to call the member function on </td></tr>
    <tr><td class="paramname">mptr</td><td>pointer to the member function to be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function object created for 'tptr' and 'mptr'</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>The add_front function does not support cv-qualifiers. Replaced by add_front(callback(obj, method)). </dd></dl>

</div>
</div>
<a id="ga539c73852cd4510b6bf5319d8b4c46d2" name="ga539c73852cd4510b6bf5319d8b4c46d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539c73852cd4510b6bf5319d8b4c46d2">&#9670;&nbsp;</a></span>mbed_die()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_die </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cause the mbed to flash the BLOD (Blue LEDs Of Death) sequence </p>

</div>
</div>
<a id="ga6a3dda312f4b7366c6715eea49b7205b" name="ga6a3dda312f4b7366c6715eea49b7205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3dda312f4b7366c6715eea49b7205b">&#9670;&nbsp;</a></span>mbed_error_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_error_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print out an error message. This is typically called when hanlding a crash.</p>
<p >@Note Synchronization level: Interrupt safe </p>

</div>
</div>
<a id="gabac932c58d3618aa41d3f0647325b718" name="gabac932c58d3618aa41d3f0647325b718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac932c58d3618aa41d3f0647325b718">&#9670;&nbsp;</a></span>mbed_error_vfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_error_vfprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print out an error message. Similar to mbed_error_printf but uses a va_list.</p>
<p >@Note Synchronization level: Interrupt safe </p>

</div>
</div>
<a id="ga03e34b12eea1c3ad7258231bcf98121b" name="ga03e34b12eea1c3ad7258231bcf98121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03e34b12eea1c3ad7258231bcf98121b">&#9670;&nbsp;</a></span>mbed_mac_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_mac_address </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This returns a unique 6-byte MAC address, based on the interface UID If the interface is not present, it returns a default fixed MAC address (00:02:F7:F0:00:00)</p>
<p >This is a weak function that can be overwritten if you want to provide your own mechanism to provide a MAC address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mac</td><td>A 6-byte array to write the MAC address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62c1213e8b7fb2133884f1cecd8dba55" name="ga62c1213e8b7fb2133884f1cecd8dba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c1213e8b7fb2133884f1cecd8dba55">&#9670;&nbsp;</a></span>mbed_mem_trace_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mbed_mem_trace_calloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trace a call to 'calloc'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>the result of running 'calloc'. </td></tr>
    <tr><td class="paramname">nmemb</td><td>the 'nmemb' argument given to 'calloc'. </td></tr>
    <tr><td class="paramname">size</td><td>the 'size' argument given to 'calloc'. </td></tr>
    <tr><td class="paramname">caller</td><td>the caller of the memory operation. @Return 'res' (the first argument). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef762d6d738c92a22183c510d44641f6" name="gaef762d6d738c92a22183c510d44641f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef762d6d738c92a22183c510d44641f6">&#9670;&nbsp;</a></span>mbed_mem_trace_default_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_mem_trace_default_callback </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Default memory trace callback. DO NOT CALL DIRECTLY. It is meant to be used as the second argument of 'mbed_mem_trace_setup'.</p>
<p >The default callback outputs trace data using 'printf', in a format that's easily parsable by an external tool. For each memory operation, the callback outputs a line that begins with '#&lt;op&gt;:&lt;0xresult&gt;;&lt;0xcaller&gt;-':</p>
<ul>
<li>'op' identifies the memory operation ('m' for 'malloc', 'r' for 'realloc', 'c' for 'calloc' and 'f' for 'free').</li>
<li>'result' (base 16) is the result of the memor operation. This is always NULL for 'free', since 'free' doesn't return anything. -'caller' (base 16) is the caller of the memory operation. Note that the value of 'caller' might be unreliable.</li>
</ul>
<p >The rest of the output depends on the operation being traced:</p>
<ul>
<li>for 'malloc': 'size', where 'size' is the original argument to 'malloc'.</li>
<li>for 'realloc': '0xptr;size', where 'ptr' (base 16) and 'size' are the original arguments to 'realloc'.</li>
<li>for 'calloc': 'nmemb;size', where 'nmemb' and 'size' are the original arguments to 'calloc'.</li>
<li>for 'free': '0xptr', where 'ptr' (base 16) is the original argument to 'free'.</li>
</ul>
<p >Examples:</p>
<ul>
<li>'#m:0x20003240;0x600d-50' encodes a 'malloc' that returned 0x20003240, was called by the instruction at 0x600D with a the 'size' argument equal to 50.</li>
<li>'#f:0x0;0x602f-0x20003240' encodes a 'free' that was called by the instruction at 0x602f with the 'ptr' argument equal to 0x20003240. </li>
</ul>

</div>
</div>
<a id="gaa5f20d537ce904f24b4deb60d69dcc2a" name="gaa5f20d537ce904f24b4deb60d69dcc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5f20d537ce904f24b4deb60d69dcc2a">&#9670;&nbsp;</a></span>mbed_mem_trace_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_mem_trace_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trace a call to 'free'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the 'ptr' argument given to 'free'. </td></tr>
    <tr><td class="paramname">caller</td><td>the caller of the memory operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a705b4981fc2deab12a6680ecdacf17" name="ga1a705b4981fc2deab12a6680ecdacf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a705b4981fc2deab12a6680ecdacf17">&#9670;&nbsp;</a></span>mbed_mem_trace_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mbed_mem_trace_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trace a call to 'malloc'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>the result of running 'malloc'. </td></tr>
    <tr><td class="paramname">size</td><td>the 'size' argument given to 'malloc'. </td></tr>
    <tr><td class="paramname">caller</td><td>the caller of the memory operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'res' (the first argument). </dd></dl>

</div>
</div>
<a id="gadbe6cd853e485351fbe6a16f91db7815" name="gadbe6cd853e485351fbe6a16f91db7815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe6cd853e485351fbe6a16f91db7815">&#9670;&nbsp;</a></span>mbed_mem_trace_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mbed_mem_trace_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trace a call to 'realloc'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>the result of running 'realloc'. </td></tr>
    <tr><td class="paramname">ptr</td><td>the 'ptr' argument given to 'realloc'. </td></tr>
    <tr><td class="paramname">size</td><td>the 'size' argument given to 'realloc'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'res' (the first argument). </dd></dl>

</div>
</div>
<a id="gaf9c5e4dcae473130cdb63f963642943c" name="gaf9c5e4dcae473130cdb63f963642943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c5e4dcae473130cdb63f963642943c">&#9670;&nbsp;</a></span>mbed_mem_trace_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_mem_trace_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga41b05bedaf7cb911c344087b8449642e">mbed_mem_trace_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the callback used by the memory tracer (use NULL for disable tracing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>the callback to call on each memory operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f630e822fbcf4f6f37f9e4e97bce210" name="ga2f630e822fbcf4f6f37f9e4e97bce210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f630e822fbcf4f6f37f9e4e97bce210">&#9670;&nbsp;</a></span>mbed_stats_heap_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_stats_heap_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbed__stats__heap__t.html">mbed_stats_heap_t</a> *&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill the passed in heap stat structure with heap stats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>A pointer to the <a class="el" href="structmbed__stats__heap__t.html">mbed_stats_heap_t</a> structure to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab05979e087023e3b4f8c4862943b7ad" name="gaab05979e087023e3b4f8c4862943b7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab05979e087023e3b4f8c4862943b7ad">&#9670;&nbsp;</a></span>mbed_stats_stack_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbed_stats_stack_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill the passed in structure with stack stats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>A pointer to the <a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> structure to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga077431ed5998c908c8a7d964a825dc94" name="ga077431ed5998c908c8a7d964a825dc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga077431ed5998c908c8a7d964a825dc94">&#9670;&nbsp;</a></span>mbed_stats_stack_get_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mbed_stats_stack_get_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> *&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill the passed array of stat structures with the stack stats for each available stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>A pointer to an array of <a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> structures to fill </td></tr>
    <tr><td class="paramname">count</td><td>The number of <a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> structures in the provided array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of <a class="el" href="structmbed__stats__stack__t.html">mbed_stats_stack_t</a> structures that have been filled, this is equal to the number of stacks on the system. </dd></dl>

</div>
</div>
<a id="ga4c8e05ae304cf02c492e46969795fe81" name="ga4c8e05ae304cf02c492e46969795fe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c8e05ae304cf02c492e46969795fe81">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="ga15fff28d8f02a51e56d972ad444aa3cb" name="ga15fff28d8f02a51e56d972ad444aa3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15fff28d8f02a51e56d972ad444aa3cb">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="gad541a6aee855641543ace2b301a50fcf" name="gad541a6aee855641543ace2b301a50fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad541a6aee855641543ace2b301a50fcf">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="ga88e580fde2c3a9ceea3d8b2025867e65" name="ga88e580fde2c3a9ceea3d8b2025867e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e580fde2c3a9ceea3d8b2025867e65">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="ga9cd4683deb8f24c6ccc028aab7ff1799" name="ga9cd4683deb8f24c6ccc028aab7ff1799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd4683deb8f24c6ccc028aab7ff1799">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="gaed5c16abdb11e378f69f90b519fcb8c2" name="gaed5c16abdb11e378f69f90b519fcb8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5c16abdb11e378f69f90b519fcb8c2">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test if function has been attached </p>

</div>
</div>
<a id="gae2be2d70c53b801ec9c06651121cba8f" name="gae2be2d70c53b801ec9c06651121cba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2be2d70c53b801ec9c06651121cba8f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gaa88ec437f9316311cae3a24f24082089" name="gaa88ec437f9316311cae3a24f24082089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa88ec437f9316311cae3a24f24082089">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gae12a59ae8df387894a3b619667201c95" name="gae12a59ae8df387894a3b619667201c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae12a59ae8df387894a3b619667201c95">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="ga119bb8263bae8c52998a379803ce52de" name="ga119bb8263bae8c52998a379803ce52de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119bb8263bae8c52998a379803ce52de">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gad32df25cf2041abd96db7469260a3db2" name="gad32df25cf2041abd96db7469260a3db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad32df25cf2041abd96db7469260a3db2">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gaa2fe615bfd9ff31aafc643c88b06e719" name="gaa2fe615bfd9ff31aafc643c88b06e719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fe615bfd9ff31aafc643c88b06e719">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Call the attached function </p>

</div>
</div>
<a id="gabc6a602e09673b7cf64c1027d52e0f74" name="gabc6a602e09673b7cf64c1027d52e0f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc6a602e09673b7cf64c1027d52e0f74">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="ga072b188609cfa2ac3b7a34d31115df68" name="ga072b188609cfa2ac3b7a34d31115df68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072b188609cfa2ac3b7a34d31115df68">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="ga2c43a737a4b09f6a8e2a64dfdab875fb" name="ga2c43a737a4b09f6a8e2a64dfdab875fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c43a737a4b09f6a8e2a64dfdab875fb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="gae9ed0d9da8cff05bd66ef3e9a077a427" name="gae9ed0d9da8cff05bd66ef3e9a077a427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ed0d9da8cff05bd66ef3e9a077a427">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="ga7c604d2d78f81e1f35be77e804ceb5a5" name="ga7c604d2d78f81e1f35be77e804ceb5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c604d2d78f81e1f35be77e804ceb5a5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="ga26d9d74d4e1f51a4fcb063ff802bcdcd" name="ga26d9d74d4e1f51a4fcb063ff802bcdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26d9d74d4e1f51a4fcb063ff802bcdcd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a> &amp; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign a callback </p>

</div>
</div>
<a id="gad3f648bd0c4c64dca2a4549eac41381c" name="gad3f648bd0c4c64dca2a4549eac41381c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f648bd0c4c64dca2a4549eac41381c">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , uint32_t BufferSize, typename CounterType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer</a>&lt; T, BufferSize, CounterType &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pop the transaction from the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to be pushed to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer is not empty and data contains a transaction, false otherwise </dd></dl>

</div>
</div>
<a id="ga7912eb5ef637aee9dec87ccc2c142027" name="ga7912eb5ef637aee9dec87ccc2c142027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7912eb5ef637aee9dec87ccc2c142027">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , uint32_t BufferSize, typename CounterType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer</a>&lt; T, BufferSize, CounterType &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Push the transaction to the buffer. This overwrites the buffer if it's full</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to be pushed to the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4396b8d6374b95f13c95775bd8e0137a" name="ga4396b8d6374b95f13c95775bd8e0137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4396b8d6374b95f13c95775bd8e0137a">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mbed::CallChain::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__platform.html#ga0deb66451ed70cb0c99bf0255e1562d1">pFunctionPointer_t</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a function object from the chain</p>
<ul>
<li>f the function object to remove</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if the function object was found and removed, false otherwise. </dd></dl>

</div>
</div>
<a id="gaeaa832ce32a966c1605af04e988c273f" name="gaeaa832ce32a966c1605af04e988c273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa832ce32a966c1605af04e988c273f">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , uint32_t BufferSize, typename CounterType  = uint32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmbed_1_1_circular_buffer.html">mbed::CircularBuffer</a>&lt; T, BufferSize, CounterType &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reset the buffer </p>

</div>
</div>
<a id="ga5d1e10825bf4a6ecdd567e9f2f384ed1" name="ga5d1e10825bf4a6ecdd567e9f2f384ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1e10825bf4a6ecdd567e9f2f384ed1">&#9670;&nbsp;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_time </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implementation of the C time.h functions</p>
<p >Provides mechanisms to set and read the current time, based on the microcontroller Real-Time Clock (RTC), plus some standard C manipulation and formating functions.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <a class="code hl_function" href="group__platform.html#ga5d1e10825bf4a6ecdd567e9f2f384ed1">set_time</a>(1256729737);  <span class="comment">// Set RTC time to Wed, 28 Oct 2009 11:35:37</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(1) {</div>
<div class="line">        time_t seconds = time(NULL);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Time as seconds since January 1, 1970 = %d\n&quot;</span>, seconds);</div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Time as a basic string = %s&quot;</span>, ctime(&amp;seconds));</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">char</span> buffer[32];</div>
<div class="line">        strftime(buffer, 32, <span class="stringliteral">&quot;%I:%M %p\n&quot;</span>, localtime(&amp;seconds));</div>
<div class="line">        printf(<span class="stringliteral">&quot;Time as a custom formatted string = %s&quot;</span>, buffer);</div>
<div class="line"> </div>
<div class="line">        wait(1);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__platform_html_ga5d1e10825bf4a6ecdd567e9f2f384ed1"><div class="ttname"><a href="group__platform.html#ga5d1e10825bf4a6ecdd567e9f2f384ed1">set_time</a></div><div class="ttdeci">void set_time(time_t t)</div></div>
</div><!-- fragment --><p> Set the current time</p>
<p >Initialises and sets the time of the microcontroller Real-Time Clock (RTC) to the time represented by the number of seconds since January 1, 1970 (the UNIX timestamp).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Number of seconds since January 1, 1970 (the UNIX timestamp)</td></tr>
  </table>
  </dd>
</dl>
<p>@Note Synchronization level: Thread safe</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <a class="code hl_function" href="group__platform.html#ga5d1e10825bf4a6ecdd567e9f2f384ed1">set_time</a>(1256729737); <span class="comment">// Set time to Wed, 28 Oct 2009 11:35:37</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga914b04b74d74f02398f93600e7ec7b27" name="ga914b04b74d74f02398f93600e7ec7b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga914b04b74d74f02398f93600e7ec7b27">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mbed::CallChain::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of functions in the chain </p>

</div>
</div>
<a id="ga9e0017bfc561308796ccc9d2ac247c2a" name="ga9e0017bfc561308796ccc9d2ac247c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e0017bfc561308796ccc9d2ac247c2a">&#9670;&nbsp;</a></span>thunk() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8dd2c178774d085bd656d4fee9fece8a" name="ga8dd2c178774d085bd656d4fee9fece8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd2c178774d085bd656d4fee9fece8a">&#9670;&nbsp;</a></span>thunk() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7dc009fa17127f9bd7c45c1a8eb95816" name="ga7dc009fa17127f9bd7c45c1a8eb95816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc009fa17127f9bd7c45c1a8eb95816">&#9670;&nbsp;</a></span>thunk() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fc4d93ca23dd7a546667857a6a8789a" name="ga1fc4d93ca23dd7a546667857a6a8789a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fc4d93ca23dd7a546667857a6a8789a">&#9670;&nbsp;</a></span>thunk() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga271ac9bd517738f0ab5008e182dc48f6" name="ga271ac9bd517738f0ab5008e182dc48f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga271ac9bd517738f0ab5008e182dc48f6">&#9670;&nbsp;</a></span>thunk() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac8173a82ace566be19aff2576e767868" name="gac8173a82ace566be19aff2576e767868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8173a82ace566be19aff2576e767868">&#9670;&nbsp;</a></span>thunk() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::thunk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A0&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Static thunk for passing as C-style function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classmbed_1_1_callback.html">Callback</a> to call passed as void pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80a48578b2a07c25aac9c1c0b55f162e" name="ga80a48578b2a07c25aac9c1c0b55f162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a48578b2a07c25aac9c1c0b55f162e">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R()&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<a id="ga28b4cbb0b3afe0f503e41c4e4da0b932" name="ga28b4cbb0b3afe0f503e41c4e4da0b932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b4cbb0b3afe0f503e41c4e4da0b932">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0)&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<a id="ga82a65106683398bab982fac7d38a6355" name="ga82a65106683398bab982fac7d38a6355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82a65106683398bab982fac7d38a6355">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1)&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<a id="ga9a2833b337ecf27be95e379f054c3992" name="ga9a2833b337ecf27be95e379f054c3992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2833b337ecf27be95e379f054c3992">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2)&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<a id="gab02b94fa63b644583ca0a9140998e563" name="gab02b94fa63b644583ca0a9140998e563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab02b94fa63b644583ca0a9140998e563">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3)&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<a id="gaa628baf42353cd60400252a7a5d3acde" name="gaa628baf42353cd60400252a7a5d3acde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa628baf42353cd60400252a7a5d3acde">&#9670;&nbsp;</a></span>~Callback() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;::~<a class="el" href="classmbed_1_1_callback.html">Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroy a callback </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gac002693cf63d9a1a05789c966de5053d" name="gac002693cf63d9a1a05789c966de5053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac002693cf63d9a1a05789c966de5053d">&#9670;&nbsp;</a></span>callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> mbed::transaction_t::callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >User's callback </p>

</div>
</div>
<a id="gab833266b58930c495adc9ca6ca6ac6ee" name="gab833266b58930c495adc9ca6ca6ac6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab833266b58930c495adc9ca6ca6ac6ee">&#9670;&nbsp;</a></span>event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mbed::transaction_t::event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Event for a transaction </p>

</div>
</div>
<a id="ga136c3a148862b61d173c9425159672f5" name="ga136c3a148862b61d173c9425159672f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136c3a148862b61d173c9425159672f5">&#9670;&nbsp;</a></span>method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M mbed::CallChain::method</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_function" href="group__platform.html#ga19929d1fbe56245a5cf4af62696ec1a6">add</a>(<a class="code hl_function" href="group__platform.html#ga79787577174689d1c0c7be04b08fc1d7">callback</a>(obj, method))</div>
<div class="ttc" id="agroup__platform_html_ga79787577174689d1c0c7be04b08fc1d7"><div class="ttname"><a href="group__platform.html#ga79787577174689d1c0c7be04b08fc1d7">mbed::callback</a></div><div class="ttdeci">Callback&lt; R()&gt; callback(R(*func)()=0)</div><div class="ttdef"><b>Definition:</b> Callback.h:3305</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga56698177b98a193cdea584d5d9e83a51" name="ga56698177b98a193cdea584d5d9e83a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56698177b98a193cdea584d5d9e83a51">&#9670;&nbsp;</a></span>rx_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbed::transaction_t::rx_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Rx buffer </p>

</div>
</div>
<a id="gafefd7a94e22cadc29445edc25d33ff68" name="gafefd7a94e22cadc29445edc25d33ff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafefd7a94e22cadc29445edc25d33ff68">&#9670;&nbsp;</a></span>rx_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mbed::transaction_t::rx_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Length of Rx buffer </p>

</div>
</div>
<a id="gabacf8c4e26c5bee9e3f45abdb065a46c" name="gabacf8c4e26c5bee9e3f45abdb065a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacf8c4e26c5bee9e3f45abdb065a46c">&#9670;&nbsp;</a></span>tx_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mbed::transaction_t::tx_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tx buffer </p>

</div>
</div>
<a id="gaa2251489b9b40afc9b6ee367d0c7746d" name="gaa2251489b9b40afc9b6ee367d0c7746d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2251489b9b40afc9b6ee367d0c7746d">&#9670;&nbsp;</a></span>tx_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mbed::transaction_t::tx_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Length of Tx buffer </p>

</div>
</div>
<a id="ga07ac843f6ce2f59a3d65d7d8beac1f11" name="ga07ac843f6ce2f59a3d65d7d8beac1f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ac843f6ce2f59a3d65d7d8beac1f11">&#9670;&nbsp;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mbed::transaction_t::width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Buffer's word width (8, 16, 32, 64) </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="ga19a2cb57f30416b3d811249789a50243" name="ga19a2cb57f30416b3d811249789a50243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a2cb57f30416b3d811249789a50243">&#9670;&nbsp;</a></span>operator!= <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for inequality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
<a id="gadc9ed4d58bf74294768014653722a608" name="gadc9ed4d58bf74294768014653722a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9ed4d58bf74294768014653722a608">&#9670;&nbsp;</a></span>operator== <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Test for equality </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
